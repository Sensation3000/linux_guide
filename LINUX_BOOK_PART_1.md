## Содержание

### Часть I Командная оболочка
- [Глава 1. Что такое командная оболочка ](#глава-1-что-такое-командная-оболочка)
- [Глава 2. Навигация](#глава-2-навигация)
- [Глава 3. Исследование системы](#глава-3-исследование-системы)
- [Глава 4. Операции с файлами и каталогами](#глава-4-операции-с-файлами-и-каталогами)
- [Глава 5. Работа с командами](#глава-5-работа-с-командами)
- [Глава 6. Перенаправление](#глава-6-перенаправление)
- [Глава 7. Взгляд на мир глазами командной оболочки](#глава-7-взгляд-на-мир-глазами-командной-оболочки)
- [Глава 8. Продвинутые приемы работы с клавиатурой](#глава-8-продвинутые-приемы-работы-с-клавиатурой)
- [Глава 9. Привилегии](#глава-9-привилегии)
- [Глава 10. Процессы](#глава-10-процессы)


## Глава 1. Что такое командная оболочка

<b>Командная оболочка</b> — это программа, которая принимает команды, введенные с клавиатуры, и передает их операционной системе для выполнения.
При запуске терминала появляется приглашение к вводу вида _user_name@computer_name_, за которым следует имя текущего каталога.
Если последний символ в приглашении - знак решетки (#), а не доллар ($), то это означает, что сеанс проходит в режиме суперпользователя.

_Пример: пользователь с обычными правами_ <br>
![alt text](pictures/image.png) <br>
_Пример: переключение в сеанс с правами root (sudo -i имитирует полноценный вход рута с окружением рута, а sudo su сохраняет окружение текущего пользователя)_<br>
![alt text](pictures/image-1.png)

#### Копирование текста
В терминале копирование производится с помощью выделения текста, нажатия правой кнопки мыши, вставка также - правая кнопка мыши (ещё можно с помощью CTRL+SHIFT+C)

#### История команд
Для вызова истории необходимо нажать клавишу со стрелкой вверх, стрелки влево и вправо позволяют менять позицию курсора в команде, тем самым редактировать ввод.

#### Некоторые простые команды

_Вывод текущей даты и времени_ <br>
![alt text](pictures/image-2.png)

_Вывод календаря текущего месяца (по умолчанию не установлен, sudo apt install ncal)_ <br>
![alt text](pictures/image-3.png)

_Объем свободного пространства на дисках (ключ -h дает удобочитаемый формат)_ <br>
![alt text](pictures/image-4.png)

_Объем свободного пространства в ОЗУ (ключ -h дает удобочитаемый формат)_<br>
![alt text](pictures/image-5.png)


_Завершение сеанса работы с терминалом: команда exit_ <br>


## Глава 2. Навигация

Первый каталог в файловой системе называется _корневым каталогом_. Корневой каталог содержит файлы и подкаталоги, которые в свою очередь также содержат файлы и каталоги, и т. д. 
В отличие от Windows, где для каждого устройства хранения создается отдельная файловая система, в Linux всегда имеется только одна файловая система, независимо от числа дисков, подключенных к компьютеру. Устройства хранения подключаются (или, как принято говорить, монтируются) к дереву файловой системы. 
Родительский каталог - вышележащий каталог от текущего местоположения в файловой системе.
Текущий рабочий каталог - это каталог, где мы находимся в данный момент.

_Вывод названия текущего рабочего каталога_ <br>
![alt text](pictures/image-6.png) <br>

Сразу после входа в систему (или запуска сеанса в эмуляторе терминала) текущим рабочим каталогом становится наш домашний каталог. Каждый пользователь имеет свой домашний каталог, который является единственным, где пользователю позволено осуществлять запись в файлы, когда он действует с привилегиями обычного пользователя.

### Вывод содержимого каталога

![alt text](pictures/image-7.png)<br>

### Смена текущего рабочего каталога

Абсолютный путь

Абсолютный путь начинается с корневого каталога и перечисляет ветви дерева, отделяющие корень от желаемого каталога или файла. <br>
![alt text](pictures/image-8.png)<br>

Относительный путь

Относительный путь начинается в рабочем каталоге. Для обозначения относительных позиций в дереве файловой системы используется
пара специальных символов: . (точка) и .. (точка-точка). Символ . (точка) обозначает рабочий каталог, а символ .. (точка-точка) обозначает каталог, родительский по отношению к рабочему. <br>
![alt text](pictures/image-9.png) <br>

Сокращенные варианты команды cd

| Команда                | Результат |
|------------------------|-----------|
| cd                     | Сменить рабочий каталог на домашний |
| cd -                   | Сменить рабочий каталог на предыдущий рабочий каталог |
| cd&nbsp;~username          | Сменить рабочий каталог на домашний каталог пользователя username. Например, cd ~olga выполнит переход в домашний каталог пользователя olga |

### Особенности имен файлов в Linux

* Файлы, имена которых начинаются с точки, считаются скрытыми. Это означает, что команда ls не будет выводить их, если не вызвать ее с ключом -a. <br>
![alt text](pictures/image-10.png) <br>
* Linux различает регистр символов в именах файлов и командах. Файлы с именами File1 и file1 — это разные файлы. <br>
* Хотя Linux поддерживает длинные имена файлов с пробелами и знаками пунктуации, старайтесь не использовать в именах файлов другие знаки пунктуации,кроме точки, дефиса и подчеркивания. И самое главное, не используйте пробелы в именах файлов. Если необходимо отделить друг от друга слова в имени файла, используйте символы подчеркивания. <br>
* Linux различает регистр символов в именах файлов и командах. Файлы с именами File1 и file1 — это разные файлы. <br>
* В Linux не поддерживается понятие «расширения файла», как в некоторых других операционных системах. Вы можете давать своим файлам любые имена. Тип и/или назначение файла определяется другими средствами. <br>

## Глава 3. Исследование системы

### Возможности команды ls

Можно явно указать каталог, содержимое которого требуется вывести. <br>
Вывод содержимого домашнего каталога, а также /usr
![alt text](pictures/image-11.png)<br>
Изменение формата вывода: команда ls -l предоставляет длинный (ключ -l --->> long) форма вывода <br>
![alt text](pictures/image-12.png) <br>

### Аргументы команды ls

| Параметр | Длинный параметр | Описание | Пример|
|-------------|-------------|-------------|-------------|
| -a       | --all | Список всех (all) файлов, включая скрытые  | ![alt text](pictures/image-13.png)  |
| -A | --almost-all | Действует подобно параметру -a, но не выводит каталоги . (текущий рабочий каталог) и .. (родительский каталог) | ![alt text](pictures/image-14.png)  |
| -d | --directory  | Информация о каталоге, а не о его содержимом. Используйте этот параметр в сочетании с параметром -l, чтобы получить дополнительную информацию о каталоге, а не о его содержимом. | ![alt text](pictures/image-15.png)  |
| -F   | --classify   | Добавляет в конец каждого имени символ-индикатор, например, прямой слеш, если это имя каталога  | ![alt text](pictures/image-16.png) |
| -h | --human-readable  | При использовании ключа -l  отображает размеры файлов не в байтах, а в величинах с единицами измерения | ![alt text](pictures/image-17.png)  |
| -l  |   | Полное описание файлов  | ![alt text](pictures/image-18.png)  |
| -r  | --reverse | Выводит результаты в обратном порядке. Обычно команда ls выводит результаты в алфавитном порядке  | ![alt text](pictures/image-19.png) |
| -S  | --size  | Сортировка по размеру | ![alt text](pictures/image-20.png) |
| -t  |  | Сортировать по времени последнего изменения  | ![alt text](pictures/image-21.png)  |

### Особенности вывода ls -l

Перед вами вывод команды ls -l <br>

![alt text](pictures/image-22.png) <br>

Рассмотрим форматы вывода и их назначения

| Формат | Назначение | 
|-------------|-------------|
| -rw-r-r--   | Права доступа к файлу. Первый символ указывает тип файла. Например, символом дефиса обозначаются обычные файлы,а символом d — каталоги. Следующие три символа сообщают о правах доступа для владельца файла, следующие три — для членов группы, которой принадлежит файл, и последние три — для всех остальных.| 
| 1  | Число жестких ссылок на файл.  | 
| olga | Имя пользователя, владеющего файлом | 
| olga  | Имя группы, владеющей файлом | 
| 4096 | Размер файла в байтах  | 
| May 12 17:25  | Дата и время последнего изменения файла  |
| java.txt | Название файла  | 

### Определение типов файлов командой file

Имена файлов в Linux не обязаны отражать тип содержимого файлов. Например, увидев имя файла picture.jpg, можно предположить, что он содержит изображение в формате JPEG, но в Linux такие предположения могут не оправдываться. 
Чтобы точно понять, что за файл перед вами, даже если у него нет расширения, выполните команду:
![alt text](pictures/image-23.png) <br>
В результате вы получите описание того, какой перед вами тип файла. Важно заметить, что одна из известных идей в Linux, гласит: «Все сущее есть файл». 

### Просмотр содержимого файлов командой less

Команда less служит для просмотра текстовых файлов с прокруткой. 

После запуска программа less позволяет прокручивать текстовый файл взад и вперед. Например, просмотреть содержимое файла со всеми известными системе учетными записями пользователей можно с помощью следующей команды:

less /etc/passwd

### Управление с клавиатуры для команды less

![alt text](pictures/image-24.png)
![alt text](pictures/image-25.png)

Если по ошибке вы попробовали просмотреть содержимое нетекстового файла и полностью нарушили нормальную работу окна терминала, вы можете вернуть его в исходное состояние, выполнив команду reset.

Команда less создавалась как улучшенная замена более ранней команды more. Ее имя — это игра слов «less is more» (меньше значит больше). В отличие от команды more, которая может листать страницы только вперед, less способна листать текст в обоих направлениях, вперед и назад, и имеет множество других
особенностей.

### Файловая система Linux

Рассмотрим некоторые основные каталоги файловой системы Linux и их предназначение

![alt text](pictures/image-26.png)
![alt text](pictures/image-27.png)
![alt text](pictures/image-28.png)

## Глава 4. Операции с файлами и каталогами

Поскольку имена файлов используются в консоли повсеместно, она поддерживает специальные символы, помогающие быстро определять группы имен файлов. Эти специальные символы называют wildcards. 

### Wildcards

![alt text](pictures/image-29.png)

### Классы символов

![alt text](pictures/image-30.png)

### Примеры использования wildcards 

![alt text](pictures/image-31.png)
![alt text](pictures/image-32.png)

### Создание каталогов

Команда mkdir позволяет создавать каталоги <br>

![alt text](pictures/image-33.png)

Если использовать ключ -p, то создаются вложенные каталоги. В примере создается test3, внутри которого находится test4. <br>

![alt text](pictures/image-34.png)

###  Копирование файлов и каталогов

Команда cp позволяет копировать файлы и каталоги <br>

Скопируем файл test в каталог test1 <br>

![alt text](pictures/image-35.png)

### Некоторые ключи команды cp

![alt text](pictures/image-36.png)

### Примеры использования команды cp

![alt text](pictures/image-37.png)

Скопируем файл с учетными записями пользователей в текущий каталог <br>

![alt text](pictures/image-38.png)

Точка в конце - это обозначение текущего каталога  <br>

Если использовать ключ -v, то мы увидим сообщение, что операция была выполнена. <br>

![alt text](pictures/image-39.png)

Обратите внимание, что cp перезаписала первую копию без каких-либо предупреждений. Это как раз тот случай,когда cp полагает, что вы знаете, что делаете. Чтобы вывести предупреждение, включите параметр -i:


![alt text](pictures/image-40.png)

Если в ответ на запрос ввести y, команда перезапишет существующий файл; если ввести любой другой символ (например, n), cp оставит прежнюю копию файла нетронутой.

### Перемещение и переименование файлов с помощью команды mv

Команда mv выполняет операции перемещения и переименования файлов в зависимости от особенностей использования. В любом случае исходный файл исчезает после операции. Команда mv используется почти так же, как команда cp: <br>

mv item1 item2 <br>

перемещает или переименовывает файл или каталог item1 в item2. <br>

mv элемент... каталог <br>

перемещает один или более элементов из одного каталога в другой. <br>

### Некоторые ключи команды mv 

![alt text](pictures/image-41.png)


### Примеры использования команды mv 

![alt text](pictures/image-42.png)


### Удаление файлов и каталогов с помощью команды rm

Команда rm используется для удаления (remove) файлов и каталогов, например: <br>
rm элемент <br>
где элемент — это один или несколько файлов или каталогов <br>

### Некоторые ключи команды rm

![alt text](pictures/image-43.png)

### Примеры использования команды rm

![alt text](pictures/image-44.png)


<b>БУДЬТЕ ОСТОРОЖНЫ С КОМАНДОЙ RM!</b>
Linux не имеет команды, отменяющей удаление. Если вы что-то удалили командой rm, это исчезнет навсегда. Linux считает вас достаточно ответственным человеком, отдающим себе отчет в своих действиях. Будьте особенно осторожны с wildcards. Рассмотрим следующий классический пример. Допустим, вы захотели удалить все файлы HTML в каталоге. <br>
Для этого вы вводите команду: <br>
rm *.html <br>
которая сделает именно то, что вам нужно, но если вы случайно вставите пробел
между * и .html, как в следующей команде: <br>
rm * .html <br>
rm удалит все файлы в каталоге и затем сообщит, что не нашла файла .html.
Полезный совет: всякий раз, используя групповые символы с командой rm (по-
мимо внимательной проверки ввода!), проверьте сначала аргумент с групповым
символом с командой ls. Это позволит увидеть, какие файлы будут удалены. За-
тем нажмите клавишу со стрелкой вверх, чтобы восстановить команду из истории,
и замените ls на rm.

### Символические и жесткие ссылки

#### Символические ссылки

Просматривая содержимое каталогов (например, /lib), нередко можно увидеть
такие записи: <br>
lrwxrwxrwx 1 root root 11 2018-08-11 07:34 libc.so.6 -> libc-2.6.so

Обратили внимание на первую букву l и на присутствие двух имен файлов в конце? Это специальный файл, который называется символической ссылкой (иногда их называют мягкими ссылками или, на жаргоне, симлинками). В большинстве Unix-подобных систем можно дать одному и тому же файлу несколько имен. Даже
притом, что на данный момент ценность такого приема может быть не очевидна, в действительности это очень удобная возможность.

Вообразите следующий сценарий: программе требуется некий разделяемый ресурс (например, библиотека), хранящийся в файле с именем «foo», но номер версии «foo» меняется очень часто. Было бы хорошо включить номер версии в имя файла, чтобы администратор или другое заинтересованное лицо могли видеть, какая версия «foo» установлена. И здесь возникает проблема. Если изменить имя разделяемого ресурса, нам придется проверять каждую программу, использующую этот ресурс, и изменять в ней имя ресурса на новое после установки новой версии ресурса. Если честно, такая перспектива не выглядит привлекательной.

Символические ссылки помогут спасти положение. Допустим, мы установили «foo» версии 2.6 с именем файла «foo-2.6» и затем создали символическую ссылку с простым именем «foo», указывающую на ресурс «foo-2.6». То есть когда программа откроет файл «foo», в действительности она откроет файл «foo-2.6». И все будут счастливы. Программы, полагающиеся на имя «foo», найдут нужный файл, а мы сможем увидеть фактическую версию ресурса. Когда придет время обновить ресурс до версии «foo-2.7», мы просто добавим файл в систему, удалим символическую ссылку «foo» и создадим новую символическую ссылку, указывающую на новую версию. Такой подход не только решает проблему обновления версий, но также позволяет сохранить на компьютере обе версии ресурса. Представьте, что в версии «foo-2.7» обнаружилась ошибка (ох уж эти разработчики!) и нужно вернуть старую версию. В этом случае достаточно просто вновь удалить символическую ссылку, указывающую на новую версию, и создать новую символическую ссылку, указывающую на старую версию. Запись выше (получена в каталоге /lib в системе Fedora) соответствует символи-
ческой ссылке с именем libc.so.6, указывающей на файл разделяемой библиотеки с именем libc-2.6.so. Это означает, что программа, ищущая libc.so.6, фактически получит файл libc-2.6.so. 


#### Жесткие ссылки

Жесткие ссылки также позволяют присвоить одному файлу несколько имен, но они действуют иначе. Жесткие ссылки — это первоначальный способ создания ссылок в Unix; символические ссылки — более позднее изобретение. По умолчанию каждый файл имеет одну жесткую ссылку, определяющую его имя. Создавая жесткую ссылку, мы создаем дополнительную запись в каталоге для файла. Жесткие ссылки имеют два важных ограничения. 
* Жесткая ссылка не может указывать на файл за пределами собственной файловой системы. Это означает, что ссылка не может указывать на файл, находящийся в другом разделе диска.
* Жесткая ссылка не может указывать на каталог.
Жесткая ссылка неотличима от самого файла. В отличие от символических ссылок, при выводе списка с содержимым каталогов жесткие ссылки никак не выделяются. При удалении жесткой ссылки удаляется только сама ссылка, а файл остается на месте (то есть пространство, занимаемое файлом, не освобождается), пока не будут удалены все жесткие ссылки на файл.

_Важно!_

Символические ссылки были придуманы с целью преодолеть ограничения жестких ссылок. Когда создается символическая ссылка, в действительности создается файл особого типа, содержащий текстовый указатель на файл или каталог. В некотором отношении они действуют подобно ярлыкам в Windows, но, конечно же,
появились задолго до ярлыков Windows. Файл, на который указывает символическая ссылка, и сама символическая ссылка почти неотличимы друг от друга. Например, если попытаться что-то записать в символическую ссылку, запись будет выполнена в файл, на который она указывает. Однако при удалении символической ссылки удаляется только символическая ссылка, но не файл. Если удалить файл до того, как будет удалена символическая ссылка, ссылка останется на месте, но будет указывать в никуда. О таких ссылках говорят, что они «битые». Во многих реализациях команда ls выделяет битые ссылки цветом, например красным, чтобы обратить на них внимание.

### Создание жестких ссылок

![alt text](pictures/image-45.png)

Посмотрим, что содержит наш каталог <br>

![alt text](pictures/image-46.png)

Прежде всего обратим внимание на второе поле в записях файлов test и test_hard_ln, мы видим число 2 - это число ссылок. Файл всегда имеет хотя бы одну жесткую ссылку, потому что имя файла определяется ссылкой. Но как же нам убедиться, что это один и тот же файл ?
Создавая жесткую ссылку, мы фактически создаем дополнительный раздел с именем, ссылающийся на тот же раздел с данными. Цепочку дисковых блоков система присваивает тому, что называется индексным узлом (inode), который затем присваивается разделу с именем. То есть каждая жесткая ссылка ссылается на определенный индексный узел с содержимым файла.
Команда ls может извлекать эту информацию. Для этого ее нужно вызвать с параметром -i:

![alt text](pictures/image-47.png)

Как видно, значение inode у исходного файла и ссылки одинаковое - они ссылаются на один и тот же объект.

### Создание символических ссылок

Они создаются почти также, как и жесткие, добавляется лишь ключ -s. 

![alt text](pictures/image-48.png)

Не забывайте, что, создавая символическую ссылку, мы фактически определяем текст, описывающий местоположение целевого файла относительно символической ссылки. В этом легко убедиться, если взглянуть на вывод команды ls:

![alt text](pictures/image-49.png)

Обратите внимание на размер символической ссылки, равный 4, - это число символов в строке test, а не размер файла, на который он указывает. 
При создании символических ссылок можно также указывать абсолютные пути, и помимо обычных файлов, символические ссылки могут указывать также на каталоги.


### Пример удаления ссылок

Удалим жесткую ссылку

![alt text](pictures/image-50.png)

Заметим, что после удаления и вывода команды ls счетчик ссылок уменьшился. А теперь удалим сам файл и посмотрим на символическую ссылку. 

![alt text](pictures/image-51.png)

Поскольку теперь символическая ссылка указывает на несуществующий файл, она стала битой. В большинстве дистрибутивов Linux команда ls особым образом настраивается на отображение битых ссылок. Битые ссылки не представляют никакой опасности, но вносят определенную путаницу. При попытке использовать битую ссылку вы увидите:

![alt text](pictures/image-52.png)


Главное, что следует помнить о символических ссылках: большинство операций с файлами воздействуют на целевой элемент, а не на саму ссылку. Однако команда rm является исключением из этого правила. Когда вы удаляете ссылку, удаляется сама ссылка, а не элемент, на который она указывает.

## Глава 5. Работа с командами

### Команда может быть:

* <b>Выполняемой программой</b>, как те файлы, что мы видели в каталоге /usr/bin. (скомпилированные бинари, код на различных ЯП) <br>
* <b>Встроенной командой внутри командной оболочки </b> - например, команды cd, pwd. Это те, которые не требуют дополнительной установки <br>
* <b>Функцией командной оболочки </b> - как пример, пользовательские шелл скрипты, встроенные в окркжение ОС
* <b>Алиасы </b> - команда, которую мы можем определить сами, сконструировав из других команд.
* <b>Ключевые слова </b> - команда, которая по сути является не командой, а частью баш скрипта, например, слово for или if

### Идентификация команд

Часто бывает полезным точно знать, к какому из типов принадлежит команда. Линукс предлагает несколько способов, как это лучше сделать:

* Команда type - строенная утилита, предназначенная для определения типа введённой команды и способа её интерпретации оболочкой. Если команда - внешний исполняемый файл, выводит путь к нему в системе.
Помогает узнать, как именно будет выполнена команда, если её ввести в терминале

 Например,

![alt text](pictures/image-53.png)

#### Для чего это нужно

1. Проверить, не подменён ли псевдонимом или функцией стандартный вызов команды (например, чтобы избежать неожиданных или вредоносных действий, пример *alias rm='rm -i'*)
2. Определить, где именно находится исполняемый файл команды
3. Убедиться, что команда действительно существует и будет выполнена ожидаемым образом

* Команда which - определение местоположения выполняемого файла


1. Показывает, где именно находится исполняемый файл команды
2. Помогает проверить, установлена ли команда и доступна ли она в текущем окружении
3. Используется для отладки, чтобы убедиться, что запускается именно нужная версия программы.
4. При наличии алиасов может показать их определение вместе с путём к исполняемому файлу
5. Опция -a позволяет вывести все найденные в PATH экземпляры команды, а не только первый

Например:

![alt text](pictures/image-54.png)


which ищет только исполняемые программы, она не способна выявлять встроенные команды или псевдонимы, замещающие фактические исполняемые программы. Если попытаться с помощью which определить местоположение встроенной команды (например, cd), мы либо ничего не получим, либо получим сообщение
об ошибке.

![alt text](pictures/image-55.png)

## Получение документации с описанием команд

### help — получение справки для встроенных команд
bash имеет встроенную справку для каждой встроенной команды. Чтобы получить ее, введите help с именем встроенной команды. Например:

![alt text](pictures/image-56.png)

Квадратные скобки в описании синтаксиса команды указывают на необязательность элемента. Вертикальная черта используется для перечисления взаимоисключающих вариантов. В примере с описанием команды
cd, приведенном выше, ее синтаксис описывается как

cd [-L|[-P[-e]]] [dir]

Эта форма записи говорит, что команда cd может принимать необязательный параметр -L или -P и необязательный аргумент dir. Если указан параметр -P, вместе с ним можно также передать параметр -e.

--help — вывод инструкции по использованию
Многие выполняемые программы поддерживают параметр --help для вывода описания синтаксиса и параметров, поддерживаемых командой. Например:

![alt text](pictures/image-57.png)

Некоторые программы не поддерживают параметр --help, но вы все равно пробуйте передать его. Часто в результате выводится сообщение об ошибке, содержащее ту же информацию о порядке использования.


### man — вывод страниц справочного руководства
Большинство программ, предназначенных для использования в командной строке, предоставляют официальную документацию, которую называют страницей справочного руководства (man-страницу). Для просмотра этих страниц используется специальная программа постраничного просмотра man. Важно, что страницы справочного руководства обычно не включают примеры использования, и их главная цель — служить справочником, а не инструкцией по использованию. Например,

![alt text](pictures/image-58.png)

man - это большое справочное руководство, которое разбито на разделы и охватывает не только  пользовательские команды, но и команды системного администрирования, форматы файлов и т.д. Ниже представлены разделы:

![alt text](pictures/image-59.png)


Иногда, чтобы найти искомое, нужно заглянуть в конкретный раздел. Это актуально для форматов файлов, названия которых часто совпадают с именами команд. Если номер раздела не указан, man всегда будет возвращать первую найденную страницу, обычно из раздела 1. Ниже приведен пример прямого указания номера
раздела:

*man 5 passwd*

выводит страницу с описанием формата файла /etc/passwd


![alt text](pictures/image-60.png)

### apropos — вывод списка подходящих команд

Кроме того, существует возможность найти страницы справочного руководства для близких совпадений с искомым термином. Несмотря на неточность, этот подход иногда оказывается полезным. Это очень удобно, когда вы знаете, что хотите сделать, но не помните точное название команды.
Ниже приводится пример поиска страниц справочного руководства по слову partition:

![alt text](pictures/image-61.png)

### whatis — вывод очень краткого описания команды
Программа whatis выводит имя и однострочное описание из страницы справочного руководства, соответствующей искомому слову:

![alt text](pictures/image-62.png)

###  info — вывод записи из справочного руководства Info
В проекте GNU имеется альтернативное руководство Info, которое часто называют info-страницами. Info-страницы выводятся с помощью программы чтения с подходящим названием info. Info-страницы содержат гиперссылки, подобно веб-страницам. Например:


![alt text](pictures/image-63.png)


### Просмотр файлов в архиве

Пакет gzip включает специальную версию less с именем zless, которая выводит содержимое текстовых файлов, сжатых архиватором gzip (ещё zcat для просмотра коротких файлов). Например, у нас есть большой текстовый файл, который находится в архиве gzip. Его можно просмотреть, не распаковывая архив с помощью команды zless. Например:

![alt text](pictures/image-64.png)

### Создание собственных команд с помощью alias

Для начала посмотрим, как можно уместить в одной строке несколько команд - для этого нужно просто отделить их друг от друга точкой с запятой:


![alt text](pictures/image-65.png)

Как видите, мы поместили три команды в одну строку. Первая выполняет переход в каталог /usr, вторая выводит его содержимое, и третья осуществляет возврат в предыдущий каталог (команда cd -), поэтому по завершении мы оказываемся там же, где и были. Давайте теперь с помощью alias превратим эту последовательность в новую команду. Первое, что мы должны сделать, — придумать имя для новой команды. Пусть это будет test. Но прежде чем продолжить, хорошо бы проверить, не занято ли уже имя test. Для этого воспользуемся командой type:

![alt text](pictures/image-66.png)


Как мы видим, это имя уже занято. Определим незанятое имя и создадим алиас:

![alt text](pictures/image-67.png)


За командой alias следует имя, сразу за которым (то есть без пробелов) следует знак «равно» и строка в кавычках, описывающая действие, присваиваемое имени. После определения псевдонима его можно использовать везде, где ожидается коман­да.

![alt text](pictures/image-68.png)


Существует одна маленькая проблема, связанная с определением псевдонимов в командной строке. Они исчезают по завершении сеанса работы с командной оболочкой. Как исправить ситуацию мы рассмотрим позже.

## Глава 6. Перенаправление

Многие программы, которыми мы уже пользовались, что-нибудь выводят на конcоль. Этот вывод часто делится на два типа:
* Результаты работы программы, то есть данные, для получения которых создавалась программа, - перенаправление стандартного вывода   
* Сообщения о состоянии или об ошибках, извещающие нас о самочувствии
программы.


Например, если взглянуть на вывод программы ls, можно увидеть, что она выводит на экран результаты своей работы и иногда сообщения об ошибках. Согласно центральной идее Linux, что «все есть файл», такие программы, как ls, в действительности выводят свои результаты в специальный файл, который называется *стандартным выводом* (standard output, часто обозначается как stdout), а сообщения о состоянии — в специальный файл *стандартный вывод ошибок* (standard error, stderr). По умолчанию оба файла, стандартный вывод и стандартный вывод ошибок, связаны с экраном и не сохраняются на диске. Кроме того, многие программы принимают ввод из специального файла с названием *стандартный ввод* (standard input, stdin), который по умолчанию связан с клавиатурой. Механизм перенаправления ввода/вывода позволяет изменять направление вывода и ввода. Обычно вывод осуществляется на экран, а ввод — с клавиатуры, но механизм перенаправления ввода/вывода позволяет изменить этот порядок вещей.


## Перенаправление стандартного вывода

Механизм перенаправления ввода/вывода позволяет явно указать, куда должен осуществляться стандартный вывод. Чтобы перенаправить стандартный вывод в другой файл вместо экрана, нужно добавить в команду оператор перенаправления > и имя файла. Где это может пригодиться? Иногда полезно сохранить вывод команды в файл. Например, можно сообщить командной оболочке, что она должна направить вывод команды ls в файл ls-output.txt вместо экрана, затем откроем файл и посмотрим его содержимое:

![alt text](pictures/image-69.png)


Прекрасно, файл не пустой. Давайте теперь повторим эксперимент с перенаправлением, но с небольшим усложнением: укажем имя несуществующего каталога:

![alt text](pictures/image-71.png)


Мы получили сообщение об ошибке. Все логично — мы указали несуществующий каталог /bin/usr, посмотрим размер файла 

![alt text](pictures/image-70.png)


Файл очистился! Это объясняется тем, что при перенаправлении вывода с помощью оператора > файл назначения всегда перезаписывается с самого начала. Поскольку команда ls не вывела никаких результатов, а только сообщение об ошибке, оператор перенаправления перезаписал файл, а затем остановился из-за ошибки, что привело к его очистке. Получается, что если вам понадобится очистить какой-нибудь файл (или создать новый, пустой файл), это можно сделать с помощью команды:

*> file_name*

Простой оператор перенаправления, без предшествующей ему команды, очистит существующий файл или создаст новый, пустой файл.

А чтобы не перетирать файл, а добавить что-нибудь в конец файла, нужно использовать оператор >>. Например:

![alt text](pictures/image-72.png)

Мы видим, что после выполнения команды с >> три раза, наш файл значительно увеличился в размере.



## Перенаправление стандартного вывода ошибок

Чтобы перенаправить стандартный вывод ошибок, нужно указать его дескриптор файла. 
Файловый дескриптор — натуральное число (идентификатор), закреплённое за определённым потоком ввода-вывода. При создании нового потока ввода-вывода (который может быть связан как с файлами, так и с каталогами, сокетами и FIFO), ядро возвращает его файловый дескриптор создавшему его процессу. Файловый дескриптор может использоваться для получения доступа к потоку.

По умолчанию Unix-оболочки связывают файловый дескриптор 0 с потоком стандартного ввода (клавиатура), файловый дескриптор 1 — с потоком стандартного вывода (терминал) и файловый дескриптор 2 — со стандартным выводом ошибок (диагностические и отладочные сообщения, информация об ошибках). 


Программа может производить вывод в любой из нескольких нумерованных файловых потоков. Первые три из них мы упомянули как стандартный ввод, вывод и вывод ошибок. Командная оболочка ссылается на них как на файловые дескрипторы 0, 1 и 2 соответственно. Командная оболочка поддерживает синтаксис перенаправления файлов с использованием номеров файловых дескрипторов. Так как стандартному выводу ошибок соответствует файловый дескриптор 2, мы можем перенаправить его таким образом:

![alt text](pictures/image-73.png)


Номер файлового дескриптора 2 помещается непосредственно перед оператором перенаправления, чтобы перенаправить стандартный вывод ошибок в файл ls-error.txt.


## Перенаправление стандартного вывода и стандартного вывода ошибок в один файл

Иногда необходимо сохранить весь вывод команды в один файл. Для этого перенаправьте сразу два потока, стандартный вывод и стандартный вывод ошибок.
Сделать это можно двумя способами. 

Первый — традиционный — работает в старых версиях командной оболочки:


![alt text](pictures/image-74.png)

Здесь выполняются два перенаправления. Сначала — перенаправление стандартного вывода в файл ls-output.txt, а затем, с использованием нотации 2>&1, — перенаправление файлового дескриптора 2 (стандартный вывод ошибок) в файловый
дескриптор 1 (стандартный вывод).


Современные версии bash поддерживают второй, более простой метод выполнения перенаправления этого вида:

![alt text](pictures/image-75.png)


В данном примере используется единственный оператор &>, перенаправляющий стандартный вывод и стандартный вывод ошибок в файл ls-output.txt. Аналогично можно перенаправить стандартный вывод и стандартный вывод ошибок с добавлением в конец одного и того же файла:

*ls -l /bin/usr &>> ls-output.txt*


### ИМЕЙТЕ В ВИДУ, ЧТО ПОРЯДОК ПЕРЕНАПРАВЛЕНИЯ ИГРАЕТ ВАЖНУЮ РОЛЬ

Перенаправление стандартного вывода ошибок всегда должно производиться после перенаправления стандартного вывода, иначе этот трюк не сработает.

Следующий пример перенаправит стандартный вывод ошибок в файл ls-output.txt:
*> ls-output.txt 2>&1*

Если порядок перенаправления изменить, как показано ниже, стандартный вывод
ошибок будет перенаправлен на экран:

*2>&1 >ls-output.txt*


### Удаление нежелательного вывода

Чтобы подавить вывод сообщений об ошибках, достаточно выполнить следующую команду:

![alt text](pictures/image-76.png)

В Linux есть специальный файл /dev/null, куда можно перенаправить вывод. Этот файл представляет собой мусорную корзину, которая принимает любой ввод и ничего с ним не делает.


### Перенаправление стандартного ввода

## Команда cat

Команда cat позволяет прочитать содержимое одного или более файлов и скопировать его в стандартный вывод.

![alt text](pictures/image-77.png)

Для начала разобьем архив на части с помощью команды

split -b 1k -d -a 3 passwd.gz part_

Описание команды:

* split — команда для разбиения файлов на части

* -b 1k — задаёт размер каждой части: 1 килобайт (1024 байта)

* Файл будет разбит на куски по 1 КБ.

* -d — использовать числовые суффиксы вместо буквенных (по умолчанию используются буквы: xaa, xab и т.д., с этой опцией — x000, x001 и т.д.)

* -a 3 — длина суффикса в имени выходных файлов равна 3 символам (например, part_000, part_001, ...)

* passwd.gz — исходный файл, который нужно разбить.

* part_ — префикс для имён выходных файлов. Итоговые файлы будут называться part_000, part_001, part_002 и т.д.


Также команда cat позволяет объединять несколько файлов в один. В качестве примера создадим архив из разных частей.


![alt text](pictures/image-79.png)


Теперь объединим их с помощью данной команды.

![alt text](pictures/image-78.png)


Заметим, что команда cat не удаляет части, их надо удалять вручную.

Теперь введем команду без аргументов и посмотрим, что получится.

![alt text](pictures/image-80.png)

Ничего не произошло, однако, если писать что-то, команда будет считывать текст со стандартного ввода до нажатия сочетания CTRL+D, что вызовет END-OF-FILE.

![alt text](pictures/image-133.png)

В отсутствие аргументов с именами файлов cat копирует содержимое стандартного ввода в стандартный вывод, поэтому-то мы и увидели, как она повторила введенную нами строку. Эту ее особенность можно использовать для создания коротких текстовых файлов. Представьте, что вам потребовалось создать файл с именем eat_more.txt, содержащий текст из примера, приведенного выше. Сделать это можно было бы так:


![alt text](pictures/image-82.png)


Теперь, когда мы знаем, что команда cat может принимать данные не только из
файлов, указанных в аргументах, но и со стандартного ввода, попробуем выполнить перенаправление стандартного ввода:


![alt text](pictures/image-83.png)


Используя оператор перенаправления <, мы изменили источник данных для стандартного ввода с клавиатуры на файл eat_more.txt. Как видите, результат получился тот же, как если бы мы просто передали единственный аргумент с именем файла. Этот способ не имеет никаких преимуществ в сравнении с передачей простого аргумента, но он демонстрирует, как можно использовать файлы в роли источника данных для стандартного ввода. Другие команды находят лучшее применение стандартному вводу.


### Pipes (пайпы)

С помощью пайпа | (вертикальная черта) стандартный вывод одной команды можно связать со стандартным вводом другой.
команда1 | команда2
Для демонстрации этого механизма нам понадобится несколько команд. Мы уже упоминали команду, которая может получать данные со стандартного ввода. Это команда less. Теперь используем less для постраничного отображения вывода любой команды, которая посылает свои результаты в стандартный вывод:

*ls -l /usr/bin | less*

Это очень удобно! С помощью этого приема можно со всем комфортом исследовать вывод любой команды, посылающей результаты на стандартный вывод.


### Фильтры

Пайпы часто используются для выполнения сложных операций с данными. Они позволяют объединить вместе несколько команд. Часто команды, используемые таким способом, называют фильтрами. Фильтры принимают ввод, изменяют его определенным образом и выводят результат. Первый из таких фильтров, который мы опробуем, — команда sort.

Представьте, что нам необходимо составить список всех выполняемых программ в каталогах /bin и /usr/bin, расположив их по алфавиту, и затем вывести его:
*ls /bin /usr/bin | sort | less*


Поскольку в команде указаны два каталога (/bin и /usr/bin), вывод команды ls будет состоять из двух сортированных списков, по одному для каждого каталога. Добавив команду sort в пайп, мы изменили данные, чтобы получить единый сортированный список.

Приведем другой пример, отсортируем строки в файле и выведем первые 10 строк.

![alt text](pictures/image-93.png)

Чтобы отсортировать в обратном порядке используется ключ -r


![alt text](pictures/image-92.png)

## РАЗЛИЧИЯ МЕЖДУ > И |
С первого взгляда трудно понять разницу между пайпом | и оператором перенаправления >. Выражаясь простым языком, оператор перенаправления связывает команду с файлом, а пайп связывает вывод одной команды с вводом другой.

*команда1 > файл1*
*команда1 | команда2*


Многие, впервые познакомившись с идеей пайпов, пробуют проделать следующий трюк, «только чтобы посмотреть, что из этого получится»:

*команда1 > команда2*

Не повторяйте этот эксперимент: иногда он может стать причиной больших проблем.
Вот конкретный пример. Зарегистрировавшись как суперпользователь, человек выполнил следующую пару команд:

 *cd /usr/bin*
 *ls > less*

Первая команда выполнила переход в каталог, где хранится большинство программ, а вторая потребовала от командной оболочки очистить файл less и записать в него вывод команды ls. Так как в каталоге /usr/bin уже имеется файл с именем less (программа less), вторая команда затерла программу в файле less текстом, который вернула команда ls, и тем самым уничтожила программу less.

*Помните, что оператор перенаправления без лишних предупреждений создает или
затирает файлы, поэтому относитесь к нему с особым вниманием.*

### uniq — поиск или удаление повторяющихся строк

Команда uniq часто используется в комбинации с командой sort. uniq принимает сортированный список данных либо со стандартного ввода, либо из файла, имя которого можно передать в единственном аргументе и по умолчанию удаляет повторяющиеся строки из списка. Поэтому, чтобы гарантировать отсутствие дубликатов в нашем списке (то есть любых программ с одинаковыми именами в каталогах /bin и /usr/bin), добавим uniq в пайп. 

*ls /bin /usr/bin | sort | uniq | less*

В этом примере мы использовали uniq для удаления любых повторяющихся строк в выводе команды sort. Если бы нам потребовалось, наоборот, получить список дубликатов, мы добавили бы в команду uniq параметр -d:

*ls /bin /usr/bin | sort | uniq -d | less*

С помощью параметра -c можно подсчитать количество повторяющихся строк:


![alt text](pictures/image-94.png)


### wc — вывод числа строк, слов и байтов
Команда wc (word count — счетчик слов) используется для подсчета числа строк, слов и байтов в файлах. 
Например:


![alt text](pictures/image-84.png)


В данном случае команда вывела три числа: число строк, число слов и число байт в файле. Подобно предыдущим командам, она может вызываться без аргументов, и в этом случае wc будет принимать данные со стандартного ввода. 
Команду удобно использовать в пайпах для подсчета: например, подсчитать число элементов в нашем сортированном списке можно так:

![alt text](pictures/image-85.png)

Существуют ключи для вывода:

* -l количество строк
* -w количество слов
* -c количество символов

![alt text](pictures/image-91.png)


### grep — поиск строк, соответствующих шаблону

В данной главе мы рассматриваем только поиск по шаблону, остальные возможности будут рассмотрены в других главах книги.

Допустим, что нам нужно найти все файлы в списке программ, которые имеют в своем имени последовательность символов zip. Результаты такого поиска могут подсказать нам, какие программы в системе имеют отношение к сжатию файлов.

Сделать это можно так:

![alt text](pictures/image-86.png)


Команда grep имеет пару удобных параметров:
* -i требует от grep игнорировать регистр символов в процессе поиска (обычно поиск выполняется с учетом регистра символов);
* -v требует от grep выводить только строки, где совпадение с шаблоном не найдено.

### head/tail — вывод первых/последних строк из файлов

Иногда требуется выводить не все результаты работы команды, а только несколько первых или несколько последних строк. Команда head выводит первые 10 строк из
файла, а tail — последние 10 строк. По умолчанию обе команды выводят 10 строк текста, но это число можно изменить с помощью параметра -n:

![alt text](pictures/image-87.png)


Другой пример с пайпом:

![alt text](pictures/image-88.png)

Команда tail позволяет наблюдать, как изменяется содержимое файла в режиме реального времени. Эту ее особенность удобно использовать для наблюдения
за появлением новых записей в файлах журналов. В следующем примере демонстрируется наблюдение за файлом messages в каталоге /var/log. В некоторых дистрибутивах Linux для этого требуется обладать привилегиями суперпользователя, поскольку файл /var/log/messages может содержать секретную информацию.


![alt text](pictures/image-89.png)

При вызове с параметром -f команда tail продолжает следить за файлом и при добавлении в конец этого файла новых строк немедленно выводит их. Так продолжается до тех пор, пока пользователь не нажмет комбинацию клавиш CTRL+C. 


### tee — чтение со стандартного ввода и запись в стандартный вывод и в файлы

Команда tee читает данные со стандартного ввода и копирует их в стандартный вывод (чтобы дать возможность передать их дальше через pipe) и в один или несколько файлов. Это позволяет, например, видеть вывод команды на экране и одновременно сохранять его в файл для последующего использования

Этa функция может пригодиться для сохранения промежуточных результатов обработки в пайпе. Ниже, продолжая один из предыдущих примеров, мы сохраним полный список файлов в каталогах в файле
ls.txt, перед тем как он будет отфильтрован командой grep:

![alt text](pictures/image-90.png)

Или такой пример:

ls -la | tee output.txt

В этом случае список файлов будет выведен на экран и сохранён в файл output.txt


## Глава 7. Взгляд на мир глазами командной оболочки

### Подстановка

Каждый раз, когда вы вводите команду и нажимаете ENTER, bash производит несколько операций с текстом, прежде чем выполнит вашу команду. Мы уже видели пару примеров, где простая последовательность символов, например *, может много значить для командной оболочки. Процесс, который происходит при этом, называется подстановкой (expansion). То есть вы вводите что-то, и это что-то замещается чем-то другим, прежде чем командная оболочка продолжит обработку. Чтобы показать, что все это значит, возьмем для примера команду echo — встроенную команду, выполняющую очень простую операцию: она выводит свои текстовые аргументы в стандартный поток вывода.

![alt text](pictures/image-95.png)

Команда echo выводит любые переданные ей аргументы. Давайте рассмотрим ещё один пример.

![alt text](pictures/image-96.png)

В данном примере echo не вывела *, потому что сам символ * означает последовательность любых символов. Перед тем, как выполнить команду echo, оболочка
замещает символ * чем-то другим (в данном случае именами файлов в текущем рабочем каталоге). После нажатия клавиши ENTER командная оболочка автоматически производит подстановку любых групповых символов в командной строке, прежде чем выполнить ее, поэтому команда echo не увидела * — она получила уже готовый результат после подстановки.

### Подстановка путей

Механизм работы групповых символов называется подстановкой пути (pathname expansion).

Приведем некоторые примеры. Допустим, содержимое каталога выгдядит вот так:

![alt text](pictures/image-97.png)

С помощью подстановок мы можем вывести все файлы, начинающиеся с какой-нибудь последовательности символов:

![alt text](pictures/image-98.png)

![alt text](pictures/image-99.png)

Или заканчивающиеся на какую-нибудь последовательности символов:

![alt text](pictures/image-100.png)

![alt text](pictures/image-134.png)

А теперь перейдём в домашний каталог и выведем всё, что начинается с заглавной буквы:


![alt text](pictures/image-102.png)

Можем даже вывести каталоги, которые находятся в других каталогах, используя подстановки и wildcards:

![alt text](pictures/image-103.png)



## Подстановка пути для скрытых файлов


Файлы с именами, начинающимися с точки, считаются скрытыми. Механизм подстановки пути также учитывает это. Как мы уже видели ранее, такая подстановка

echo * 

не покажет скрытые файлы.
На первый взгляд кажется, что можно было бы включить скрытые файлы в подстановку, добавив в начало шаблона точку, например:

echo .*

ls -d .* | less

Дело в том, что эти имена соответствуют текущему рабочему каталогу и родительскому каталогу, применение такого шаблона может привести к неправильным результатам. 

Чтобы обеспечить правильную подстановку пути в такой ситуации, следует использовать специализированный шаблон. Следующий шаблон действует правильно:

ls -d .[!.]?*

![alt text](pictures/image-104.png)


Этот шаблон замещается именами файлов, начинающимися с единственной точки, за которой следует любое количество других символов. Он будет работать правильно с большинством имен скрытых файлов (кроме тех, что начинаются с нескольких точек). Команда ls с параметром -A («almost all» — «почти все») выведет список всех скрытых файлов без ошибок (не выводит текущий рабочий каталог (точка) и родительский (две точки)).

![alt text](pictures/image-105.png)

### Подстановка тильды

Тильда в начале слова - это домашний каталог пользователя. Можно данные по домашнему каталогу или по известному пользователю.

![alt text](pictures/image-106.png)

### Подстановка результатов арифметических выражений

Командная оболочка поддерживает также подстановку результатов арифметических выражений. Это позволяет использовать командную строку как калькулятор. Для подстановки арифметических выражений используется следующий формат:

$((выражение)) 

где выражение — это арифметическое выражение, состоящее из значений и арифметических операторов. Механизм подстановки арифметических выражений позволяет использовать только целые числа.


![alt text](pictures/image-107.png)

Приведём арифметические операции:

![alt text](pictures/image-108.png)


_!Важное замечание!_

В Linux существует полноценный калькулятор, для Ubuntu под Gnome установка выполняется вот таким образом:

_sudo apt install gnome-calculator_

Запуск калькулятора возможен из консоли командой gnome-calculator

![alt text](pictures/image-159.png)

Либо через UI, вызвав нужное приложение Calculator

![alt text](pictures/image-160.png)



### Подстановка фигурных скобок

С помощью данной подстановки можно создавать большое количество разнообразных файлов. Например:


![alt text](pictures/image-109.png)


Внутри фигурных скобок находится список строк, разделенных запятыми, или диапазон целых чисел или одиночных символов. Использование пробелов внутри фигурных скобок не допускается.

![alt text](pictures/image-110.png)


Такая возможность может очень хорошо пригодиться для формирования списков файлов или каталогов, которые требуется создать.

![alt text](pictures/image-111.png)


### Подстановка параметров


Существуют различные предустановленные переменные в ОС Linux. Например, переменная с именем USER хранит ваше имя пользователя. Подстановка параметра и получение содержимого переменной USER выполняется следующим образом:


![alt text](pictures/image-112.png)


Чтобы увидеть список доступных переменных, выполните следующую команду:

*printenv | less*

Если в других вариантах подстановки допустить ошибку в шаблоне, подстановка не будет выполнена и команда echo просто выведет ошибочный шаблон. В случае с подстановкой параметров все иначе: если ошибиться в имени переменной, подстановка все равно будет выполнена, но результатом будет пустая строка:

![alt text](pictures/image-113.png)


### Подстановка команд

Подстановка команд позволяет использовать поток вывода команд в качестве аргументов других команд:

![alt text](pictures/image-114.png)

Интересн второй вывод: результат команды which cp передается как аргумент команде ls, благодаря чему мы получаем информацию о программе cp, не зная полного пути к ней.


Механизм подстановки команд имеет альтернативный синтаксис, унаследованный от более старых командных оболочек, который также поддерживается в bash. В нем вместо знака доллара и круглых скобок используются обратные апострофы:

![alt text](pictures/image-115.png)


### Экранирование

Экранирование - это механизм, который служит выборочного подавления нежелательной подстановки. Например, в первом выводе пробелы схлопываются, а во втором - вместо $1 подставляется пустая строка, потому что переменная с таким названием не найдена.

![alt text](pictures/image-116.png)


#### Двойные кавычки

Если заключить текст в двойные кавычки, все специальные символы потеряют свое
специальное значение и будут интерпретироваться как обычные символы. Исключение составляют: $ (знак доллара), \ (обратный слеш) и ` (обратный апостроф). То есть разбиение на слова, подстановка путей, подстановка тильды и подстановка фигурных скобок выполняться не будут, но подстановка параметров, подстановка значений арифметических выражений и подстановка команд все еще будут выполняться. Благодаря двойным кавычкам мы сможем обрабатывать имена файлов с пробелами.


![alt text](pictures/image-117.png)

Запомните: подстановка параметров, подстановка значений арифметических выражений и подстановка команд все еще выполняются в двойных кавычках. Обратите внимание на вывод в кавычках и без:

![alt text](pictures/image-118.png)

По умолчанию находятся пробелы, символы табуляции и символы перевода строки и интерпретирются как разделители слов. То есть вне кавычек упомянутые символы не считаются частью текста. Они являются лишь разделителями. Поскольку они делят слова на аргументы, получается, что в нашем примере командная строка состоит из команды и нескольких аргументов. Однако если добавить двойные кавычки, разбиение на слова выполняться не будет и внутренние пробелы не будут считаться разделителями — они станут частью аргумента.


#### Одиночные кавычки

Если вам требуется подавить все подстановки, используйте одиночные кавычки. Ниже для сравнения приводятся результаты неэкранированной команды и команды экранированной двойными и одиночными кавычками:


![alt text](pictures/image-119.png)

#### Экранирование символов

Чтобы заэкранировать один символ, перед ним надо добавить обратный слеш.

![alt text](pictures/image-120.png)

#### Управляющие последовательности

Обратный слеш используется не только в роли экранирующего символа, но и как часть специальных символов, которые называют управляющими кодами.

Некоторые символы:

\a --->> звуковой сигнал
\b --->> backspace
\n --->> перевод строки
\r --->> возврат каретки
\t --->> табуляция

Ключ -e команды echo позволяет интерпретировать данные коды. Их можно также заключать в конструкцию $' '. Ниже демонстрируется использование команды sleep для создания таймера - пользователь ждет указанное число секунд, и программа завершается. В примере указаны два варианты использования синтаксиса.

![alt text](pictures/image-121.png)


## Глава 8. Продвинутые приемы работы с клавиатурой

### Перемещение курсора

Ниже перечислены комбинации клавиш, используемые для перемещения курсора.

![alt text](pictures/image-122.png)

### Редактирование текста

Ниже перечислены комбинации клавиш, используемые для редактирования текста.

![alt text](pictures/image-123.png)


Ниже перечислены комбинации клавиш, используемые для вырезания и вставки текста.

![alt text](pictures/image-124.png)

### Донабор текста, клавиша TAB

Если в процессе работы в консоли нажать клавишу TAB, то команда дополняется до существующих вариантов. Например: 

![alt text](pictures/image-125.png)

Если сейчас нажать клавишу TAB, то пользователь увидит команду *ls passwd*. Это очень полезная функция, которая помогает сэкономить кучу времени во время набора команд.

Приведем некоторые сочетания клавиш, которые помогут в донаборе текста.


![alt text](pictures/image-126.png)

### Просмотр истории команд

Bash поддерживает историю вводившихся команд. Этот список команд хранится в домашнем каталоге, в файле с именем .bash_history. История команд помогает уменьшить объем ручного ввода, особенно в сочетании с командами редактирования командной строки.


###  Поиск в истории
Просмотреть содержимое истории можно в любой момент с помощью команды:

*history | less*

По умолчанию bash хранит последние 500 введенных команд, однако в большинстве современных дистрибутивов этот предел увеличен до 1000.

А теперь представим, что вам понадобилось найти команды, использовавшиеся для получения списка содержимого /usr/bin. Вот один из возможных способов:


![alt text](pictures/image-127.png)


А теперь представим, что среди результатов нужно выбрать запись с интересующей вас командой:


1545  ls -l /usr/bin > ls-output.txt

Здесь число 1545 — это порядковый номер записи команды в списке истории. Можно вызвать конкретно эту команду вот таким способом.

![alt text](pictures/image-128.png)



bash также дает возможность выполнять поступательный поиск в списке истории. Это означает, что bash может выполнять поиск в списке истории по мере ввода символов, уточняя результаты с вводом каждого нового символа. Чтобы запустить поступательный поиск, нажмите комбинацию CTRL+R и введите искомый текст. Закончив поиск, нажмите ENTER, чтобы выполнить команду, или CTRL+J, чтобы скопировать запись из списка истории в текущую командную строку. Чтобы найти следующее вхождение текста (переместиться «вверх» по списку истории), нажмите CTRL+R еще раз. Чтобы завершить поиск, нажмите CTRL+G или CTRL+C.

Некоторые команды для работы с историей:


![alt text](pictures/image-129.png)


### Подстановка записей истории

Командная оболочка поддерживает специализированный вид подстановки — подстановку записей из списка истории при использовании символа !. Мы уже видели, как восклицательный знак, сопровождаемый числом, замещается записью из списка истории.
Приведем команды постановки:

![alt text](pictures/image-130.png)


Не используйте формы !строка и !?строка, если только вы абсолютно точно не знаете содержимого записей в списке истории.


### Запись истории команд в файл

В дополнение к истории команд в bash большинство дистрибутивов Linux включают программу script, которую можно использовать для записи в файлы целых сеансов работы с командной оболочкой. Базовый синтаксис команды:

script [файл]

где файл — это имя файла для записи. Если файл не будет указан, сохранение
сеанса будет произведено в файл typescript.


![alt text](pictures/image-131.png)


Выход из записи и сохранение данных в файл делается с помощью ключевого слова exit. 

Вот так выглядит история команд. записанная в файл с дефолтным именем typescript в программе nano.

![alt text](pictures/image-132.png)

## Глава 9. Привилегии

Операционные системы, следующие традициям Unix, отличаются от систем, следующих традициям MS-DOS, тем, что являются не только многозадачными, но
и многопользовательскими.
Поддержка многопользовательского режима работы — не недавнее «изобретение»
Linux, а возможность, глубоко внедренная в архитектуру операционной системы.
Чтобы подобная возможность имела практическую ценность, необходим способ
определенной «изоляции» пользователей друг от друга. В конце концов, действия
рядового пользователя не должны приводить к аварийному завершению работы
компьютера, и ни один пользователь не должен иметь возможность вносить изменения в файлы, принадлежащие другому пользователю.
В этой главе мы будем рассматривать способы ограничения, изменения доступа пользовтелей в ОС linux. 


### Владельцы, члены группы и все остальные

Ранее мы видели вот такие сообщения при доступе к некоторым файлам.

![alt text](pictures/image-135.png)

Дело в том, что обычные пользователи не имеют права читать данный файл.
В модели безопасности Linux пользователь может владеть файлами и каталогами.
Если пользователь владеет файлом или каталогом, он может управлять доступом
к нему. Пользователи могут также принадлежать группе, состоящей из одного
или нескольких пользователей, и получить права доступа к файлам и каталогам
для членов группы, которые определяются владельцами. Кроме прав доступа
для группы, владелец может также определить некоторые права доступа для всех
остальных пользователей. Получить информацию о своей идентичности можно с помощью команды id:


![alt text](pictures/image-136.png)


Давайте рассмотрим этот вывод. Когда создается учетная запись пользователя, ей присваивается число, которое называют идентификатором пользователя (user ID), или uid. Это число, исключительно ради удобства человека, отображается как имя пользователя. Пользователю назначается идентификатор основной группы (primary group ID), или gid, и дополнительно пользователь может включаться в состав других групп. В Ubuntu обычный пользователь имеет идентификатор 1000, и пользователь принадлежит множеству различных групп. 


А где же вся эта информация хранится? Как и многое другое в Linux, она хранится в паре текстовых файлов. Учетные записи пользователей хранятся в файле /etc/passwd, а информация о группах — в файле /etc/group. Когда создаются новые учетные записи и группы, эти файлы изменяются вместе с файлом /etc/shadow, где хранится информация о пароле пользователя. Для каждой учетной записи в файле /etc/passwd определяется имя пользователя (для входа), числовой идентификатор пользователя (uid), числовой идентификатор основной группы (gid), действительное имя пользователя, путь к домашнему каталогу и командная оболочка входа (login shell). 

![alt text](pictures/image-137.png)


Заглянув внутрь /etc/passwd и /etc/group, можно заметить, что помимо учетных записей обычных пользователей здесь также хранятся учетные записи суперпользователя (uid 0) и различных других системных пользователей.

Несмотря на то что во многих Unix-подобных системах обычных пользователей
включают в общую группу, такую как users, в современных дистрибутивах Linux
принято создавать для каждого пользователя свою, уникальную группу с одним
членом и именем, совпадающим с именем пользователя. Это упрощает распределение определенных типов привилегий.

### Чтение, запись и выполнение


Права доступа к файлам и каталогам определяются в терминах права на чтение,
права на запись и права на выполнение. Если взглянуть на вывод команды ls,
можно увидеть некоторые подсказки о том, как эти права реализованы.

![alt text](pictures/image-138.png)

Первые 10 символов в выводе — это атрибуты файла. Первый из этих символов
определяет тип файла. Ниже таблица, в которой указаны типы файлов, которые чаще всего встречаются на практике.

![alt text](pictures/image-139.png)

Остальные девять символов в атрибутах файла называются режимом доступа
к файлу и представляют права на чтение, запись и выполнение для владельца файла, группы — владельца файла и всех остальных. 

Установленные атрибуты r, w, x оказывают определенное влияние на файлы и каталоги. В таблице ниже приведены атрибуты прав доступа.

![alt text](pictures/image-140.png)

В таблице ниже перечислены примеры установки атрибутов и их значения.

![alt text](pictures/image-141.png)
![alt text](pictures/image-142.png)

### Chmod - изменение режима доступа к файлу

Для изменения режима (прав) доступа к файлу или каталогу используется команда chmod. Имейте в виду, что права доступа к файлу или каталогу может изменить
только владелец или суперпользователь. Команда chmod поддерживает два разных
способа изменения режима:
* с использованием восьмеричных чисел;
* с использованием символического представления.

Сначала рассмотрим использование восьмеричных чисел. При использовании
восьмеричной формы записи шаблон желаемых привилегий определяется восьмеричными числами. Так как каждая цифра в восьмеричном числе определяется тремя двоичными разрядами, она точно укладывается в схему хранения режима
доступа к файлу. Ниже в таблице приводятся примеры соответствия.

![alt text](pictures/image-143.png)

С помощью трех восьмиричных цифр мы можем определить режим доступа к файлу для владельца, группы и остальных пользователей:


![alt text](pictures/image-144.png)


Передав аргумент 600, мы установили права для владельца, позволяющие ему
читать данные из файла и записывать их в файл, и при этом отобрали все права
у группы и остальных пользователей. Несмотря на кажущееся неудобство необходимости
запоминания соответствий между восьмеричными и двоичными представлениями, вам, скорее всего, придется использовать лишь несколько наиболее популярных шаблонов:

 7 (rwx), 6 (rw-), 5 (r-x), 4 (r--) и 0 (---).

Команда chmod поддерживает также символическую форму определения режимов
доступа к файлу. Символическая форма записи делится на три части:
* для кого устанавливаются разрешения
* какие операции с разрешениями будут выполняться
* на какие разрешения эти операции будут влиять.
Чтобы указать, для кого устанавливаются разрешения, используется комбинация
символов u, g, o и a, как показано в таблице ниже.

![alt text](pictures/image-145.png)

Если не указан ни один символ, предполагается a (all — все). Операцией может
быть знак +, соответствующий добавлению заданных разрешений, знак -, соответствующий объему заданных разрешений, или знак =, указывающий, что только заданные разрешения должны быть установлены, а все остальные отобраны. Разрешения определяются символами r, w и x. В таблице ниже приведены примеры.

![alt text](pictures/image-146.png)


### Установка режима доступа к файлу с помощью графического интерфейса

Теперь, ознакомившись с тем, как устанавливаются разрешения для файлов и каталогов, вы лучше поймете диалоги установки разрешений в графическом интерфейсе. В Ubuntu можно щелкнуть правой кнопкой мыши на файле или на каталоге и вывести диалог со свойствами. Ниже представлен пример.Здесь вы видите, какие разрешения установлены для владельца, группы и остальных пользователей.

![alt text](pictures/image-147.png)

### umask — определение разрешений доступа к файлам по умолчанию

Команда umask определяет разрешения по умолчанию, которые устанавливаются
для файла при его создании. В ней с помощью восьмеричной формы записи определяется битовая маска для сбрасываемых атрибутов режима доступа. Взгляните:

![alt text](pictures/image-148.png)

Сначала мы удалили существующий файл foo.txt, чтобы, так сказать, начать с чистого листа. Далее мы выполнили команду umask без аргумента, чтобы увидеть
текущее значение маски. Она вернула нам значение 0002 (часто также используется значение 0022) — восьмеричное представление действующей маски. Затем мы
создали новый файл foo.txt и вывели для него разрешения.
Как видите, владелец и группа получили права на чтение и запись, тогда как
все остальные — только право на чтение, не получив права на запись
из-за значения маски. Давайте повторим пример, но на этот раз определим свою
маску:

![alt text](pictures/image-149.png)

После установки маски в значение 0000 (таким способом мы фактически выключили ее) вновь созданный файл получил разрешение на запись для всех пользователей.
Чтобы лучше понять суть происходящего, мы снова должны вернуться к восьмеричным числам. Если развернуть маску в двоичное представление и сравнить ее
с двоичным представлением атрибутов, можно понять, что произошло:

![alt text](pictures/image-150.png)


Забудем пока про начальные нули (мы вернемся к ним чуть позже) и обратим
внимание, что атрибут, соответствующий той позиции, где в маске стоит 1, был
сброшен, — в данном случае право на запись для всех пользователей. Теперь понятно, что делает маска. В любой позиции, где в маске появляется 1, соответствующий атрибут сбрасывается. Если посмотреть на значение маски 0022, легко увидеть, что оно делает:

![alt text](pictures/image-151.png)

И снова атрибуты, соответствующие позициям, где в маске стоит 1, были сброшены. На самом деле, вам редко придется изменять маску, потому что значение по умолчанию, устанавливаемое дистрибутивом, прекрасно подходит для большинства нужд. Однако
в некоторых ситуациях, требующих повышенной безопасности, маску может понадобиться изменить. В таблице ниже приведены цифровые обозначения umask.

![alt text](pictures/image-152.png)


Кратко:

* umask задаёт "маску", которая вычитается из полного набора прав (666 для файлов и 777 для директорий).

* Например, umask 0022 запрещает запись группе и остальным, поэтому файлы получают права 644, а директории — 755.

* Значение umask 0002 часто используется для обычных пользователей, чтобы разрешить запись группе.

* Значение umask 0022 типично для суперпользователя (root), чтобы ограничить запись только владельцем.

### Изменение идентичности

Время от времени необходимо выполнить программу от имени другого пользователя. Для этого существуют три способа:

* Выйти из системы и войти вновь с учетными данными другого пользователя.
* Воспользоваться командой su.
* Воспользоваться командой sudo.


Мы пропустим первый способ, потому что уже знаем, как им воспользоваться,
и он не так удобен, как два других. В рамках сеанса работы с командной оболочкой команда su позволяет выполнять команды от имени другого пользователя - либо
начать новый сеанс командной оболочки с идентификатором этого пользователя,
либо запустить одиночную команду от его имени. 

Команда sudo позволяет администратору записать настройки в конфигурационный файл с именем /etc/sudoers и определить конкретные команды, которые сможет выполнять тот или иной пользователь под приобретенной учетной записью. Выбор между su и sudo в значительной степени определяется используемым дистрибутивом Linux. Большинство
дистрибутивов включают обе команды, но в настройках предпочтение отдается
той или иной. Начнем с команды su.

#### su — запуск командной оболочки с подстановкой идентификаторов пользователя и группы

Команда su используется для запуска нового сеанса работы с командной оболочкой от имени другого пользователя. Команда имеет следующий синтаксис:

su [-[l]] [пользователь]

Если указан параметр -l, запущенная командная оболочка станет оболочкой входа для указанного пользователя. Это означает, что будет загружено окружение пользователя и текущим рабочим каталогом станет домашний каталог пользователя. Часто это именно то, что требуется. Если пользователь не указан, подразумевается суперпользователь. Обратите внимание, что (довольно необычно) параметр -l можно сократить до -, и эта особенность часто используется на практике.

Запустить командную оболочку от имени суперпользователя можно следующим
образом:


[me@linuxbox ~]$ su -
Пароль:
[root@linuxbox ~]#


После ввода команды будет запрошен пароль суперпользователя. После ввода
правильного пароля появится новое приглашение к вводу, показывающее, что
данная командная оболочка обладает привилегиями суперпользователя (символ #
в конце вместо символа $) и текущим рабочим каталогом теперь стал домашний
каталог суперпользователя (обычно /root).
Важно, что по умолчанию root аккаунт может быть отключен. В некоторых дистрибутивах Linux, таких как Ubuntu, учетная запись root по умолчанию отключена и не имеет пароля (включить можно через команду sudo passwd root). В этом случае команда su без указания имени пользователя (или с явным указанием su root) может не работать, пока вы не установите пароль для root.

С помощью su можно так же просто выполнить единственную команду, не запуская новый интерактивный сеанс:

su -c 'команда'

При использовании этой формы команде su передается единственная командная строка для выполнения. Не забудьте заключить команду в кавычки, чтобы предотвратить дополнительную ее интерпретацию механизмами подстановки текущей командной оболочки:


[me@linuxbox ~]$ su -c 'ls -l /root/*'
Пароль:
-rw------- 1 root root
754 2007-08-11 03:19 /root/anaconda-ks.cfg
/root/Mail:
итого 0
[me@linuxbox ~]$

#### sudo — выполнение команды от имени другого пользователя


Команда sudo во многом подобна команде su, но имеет некоторые важные дополнительные особенности. Администратор может определить порядок использования sudo обычными пользователями, ограничив возможность запуска команд
от имени другого пользователя (обычно суперпользователя). В частности, пользователю может быть разрешен доступ к одним командам и запрещен к другим.

Еще одно важное отличие состоит в том, что sudo не требует ввода пароля суперпользователя. Для аутентификации в команде sudo пользователь должен ввести
свой пароль. Например, допустим, что настройки sudo позволяют выполнить
некоторую мифическую программу резервного копирования с именем backup_script, требующую привилегий суперпользователя. С помощью sudo ее можно запустить так:

[me@linuxbox ~]$ sudo backup_script
Пароль:
System Backup Starting...


После ввода команды вам будет предложено ввести пароль (ваш, а не суперпользователя), и по завершении аутентификации указанная команда будет выполнена.

Одно важное отличие между su и sudo — последняя не запускает новую командную оболочку и не загружает окружение другого пользователя. Это означает, что
команды не требуется экранировать как-то иначе, чем при запуске той же команды без использования sudo. Имейте в виду, что такое ее поведение можно переопределить с помощью различных параметров. 
Также отметьте, что sudo можно использовать для запуска интерактивного сеанса с привилегиями суперпользователя (почти так же, как командой su -), передав ей параметр -i. 


Чтобы увидеть, какие привилегии дает команда sudo, вызовите ее с параметром -l:


![alt text](pictures/image-153.png)

Также можно комбинировать функциональность sudo и su, используя sudo -su <command>

Сочетание sudo -su позволяет перейти в оболочку root, используя пароль текущего пользователя (через sudo), а не пароль root, и получить полноценную среду root-пользователя. Это удобно, когда root-пароль неизвестен или отключен, но у вас есть права sudo.


#### UBUNTU И SUDO

Обычные пользователи иногда сталкиваются с необходимостью выполнить некоторую операцию, требующую привилегий суперпользователя. К числу таких операций относится установка и обновление программного обеспечения, правка системных конфигурационных файлов и доступ к устройствам. В мире Windows эта проблема часто решается передачей пользователям административных привилегий, что позволяет им решать подобные задачи. Однако программы, запускаемые такими пользователями, получают те же привилегии. В большинстве случаев это именно то, что нужно, но это также дает возможность беспрепятственной работы вредоносному программному обеспечению, такому как вирусы. В мире Unix, вследствие многопользовательской природы этой операционной
системы, всегда проводилась четкая грань между обычными пользователями
и администраторами. Идеология Unix заключается в том, чтобы предоставлять
привилегии суперпользователя, только когда они действительно необходимы. Для
этого часто используются команды su и sudo.

Еще несколько лет тому назад большинство дистрибутивов Linux использовали
с этой целью команду su. Команда su не требует настройки, как команда sudo,
а наличие учетной записи root — давняя традиция в Unix. Вместе это порождает
проблему. Пользователи могут испытывать соблазн действовать от имени root без
всякой необходимости. Фактически некоторые пользователи вообще работают
в своих системах, регистрируясь исключительно как root, чтобы избежать появления раздражающих сообщений «permission denied» (доступ запрещен). Такой
подход ухудшает защищенность Linux, низводя ее до уровня Windows. Не самое
лучшее решение. Создатели Ubuntu предприняли иной подход. По умолчанию Ubuntu запрещает регистрироваться в системе с учетной записью root (не позволяя устанавливать пароль для этой учетной записи), а для получения привилегий суперпользователя предлагает использовать sudo. Начальная учетная запись пользователя обладает полным доступом к привилегиям суперпользователя через sudo и может наделять аналогичными привилегиями другие, вновь создаваемые учетные записи.

### chown — изменение владельца и группы файла

Команда chown используется для изменения владельца и группы файла или каталога. Для использования этой команды необходимы привилегии суперпользователя. Команда chown имеет следующий синтаксис:

chown [владелец][:[группа]] файл...

chown может изменить владельца и/или группу файла в зависимости от первого
аргумента. Ниже в таблице приводятся аргументы команды.

![alt text](pictures/image-154.png)


Представьте, что существуют два пользователя: janet, имеющий доступ к привилегиям суперпользователя, и tony, лишенный таких привилегий. Пользователю janet нужно скопировать файл из своего домашнего каталога в домашний каталог пользователя tony. Поскольку пользователь janet хочет, чтобы пользователь tony смог редактировать файл, janet должен изменить владельца скопированного фай-
ла, назначив владельцем tony:

[janet@linuxbox ~]$ sudo cp myfile.txt ~tony <br>
Пароль: <br>
[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt <br>
-rw-r--r-- 1 root root 8031 2018-03-20 14:30 /home/tony/myfile.txt <br>
[janet@linuxbox ~]$ sudo chown tony: ~tony/myfile.txt <br>
[janet@linuxbox ~]$ sudo ls -l ~tony/myfile.txt <br>
-rw-r--r-- 1 tony tony 8031 2018-03-20 14:30 /home/tony/myfile.txt <br>

Здесь видно, как пользователь janet копирует файл из своего каталога в домашний
каталог пользователя tony. Далее janet заменяет владельца файла root (результат
использования sudo) на tony. Добавив двоеточие в конец первого аргумента, janet
одновременно изменяет группу, которой принадлежит файл, на основную группу
пользователя tony, которая, так уж получилось, носит то же имя tony.
Заметили ли вы, что после первого использования команда sudo не предложила
пользователю janet вновь ввести пароль? Это объясняется тем, что в большинстве конфигураций sudo продолжает «доверять» пользователю в течение нескольких минут (пока не истечет время ее действия).


Пример с пользователем test

![alt text](pictures/image-155.png)

### chgrp — изменение группы файла

В старых версиях Unix команда chown изменяла только владельца файла, но не
группу. Чтобы изменить группу, предоставлялась другая команда, chgrp. Она действует практически так же, как chown, но имеет больше ограничений.

### Использование привилегий

Теперь, когда мы разобрались, как действует механизм привилегий, самое время
научиться пользоваться ими. Далее демонстрируется решение типичной задачи —
настройка общего каталога. Представьте себе двух пользователей, bill и karen.
Оба имеют коллекции музыкальных произведений и хотели бы настроить общий
каталог, где могли бы хранить файлы в формате Ogg Vorbis или MP3. Пользователь bill имеет доступ к привилегиям суперпользователя через sudo.
Первое, что нужно сделать, — это создать группу, куда будут входить оба пользователя, bill и karen. С помощью графического инструмента для управления пользователями bill создает группу с именем music и добавляет в нее пользователей
bill и karen, как показано на рисунке ниже.

![alt text](pictures/image-156.png)

Чтобы вызвать этот диалог на Ubuntu, необходимо установить набор утилит

sudo apt install gnome-system-tools

Затем перезагрузить компьютер, так как должны правильно подтянуться все переменные окружения. 

Если выдается ошибка, то прописать

export DISPLAY=:0
export XAUTHORITY=/home/olga/.Xauthority

![alt text](pictures/image-158.png)


Далее bill создает каталог для музыкальных файлов: <br>
[bill@linuxbox ~]$ sudo mkdir /usr/local/share/Music <br>
Пароль: <br>
Поскольку bill манипулирует файлами за пределами своего домашнего каталога,
ему необходимы привилегии суперпользователя. После создания каталог полу-
чает следующие права доступа и владельца: <br>

[bill@linuxbox ~]$ ls -ld /usr/local/share/Music <br>

drwxr-xr-x 2 root root 4096 2018-03-21 18:05 /usr/local/share/Music <br>

Как видите, каталогом владеет root, и для него установлен режим доступа 755.
Чтобы сделать каталог общим, bill должен изменить группу каталога и права до-
ступа для группы: <br>

[bill@linuxbox ~]$ sudo chown :music /usr/local/share/Music <br>
[bill@linuxbox ~]$ sudo chmod 775 /usr/local/share/Music <br>
[bill@linuxbox ~]$ ls -ld /usr/local/share/Music <br>
drwxrwxr-x 2 root music 4096 2018-03-21 18:05 /usr/local/share/Music <br>

И что все это означает? А означает это следующее: владельцем каталога /usr/
local/share/Music является root, и члены группы music получают права на запись
и чтение в этом каталоге. Группа music включает пользователей bill и karen; то
есть bill и karen могут создавать файлы в каталоге /usr/local/share/Music. Другие
пользователи могут просматривать содержимое каталога, но не могут создавать
файлы в нем.

Но остается нерешенной еще одна проблема. С текущими разрешениями файлы
и каталоги внутри каталога Music будут создаваться с обычными разрешениями
для пользователей bill и karen:

[bill@linuxbox ~]$ > /usr/local/share/Music/test_file
[bill@linuxbox ~]$ ls -l /usr/local/share/Music
-rw-r--r-- 1 bill
bill
0 2018-03-24 20:03 test_file

В действительности здесь наблюдаются две проблемы. Во-первых, маска umask
в этой системе имеет значение 0022, что не позволяет членам группы записывать
в файлы, принадлежащие другим членам группы. Это не проблема, если общий
каталог хранит только файлы, но так как в данном каталоге предполагается хранить музыкальные произведения, а музыкальные произведения обычно принято
организовывать в иерархии по исполнителям и альбомам, членам группы может
понадобиться создавать файлы в каталогах, принадлежащих другим членам. Нам
нужно изменить маску umask для пользователей bill и karen на 0002.


Во-вторых, каждый файл и каталог, созданный одним членом группы, будет при-
надлежать основной группе пользователя, а не группе music. Исправить этот недо-
статок можно установкой бита setgid на каталог:
[bill@linuxbox ~]$ sudo chmod g+s /usr/local/share/Music
[bill@linuxbox ~]$ ls -ld /usr/local/share/Music
drwxrwsr-x 2 root music 4096 2018-03-24 20:03 /usr/local/share/Music
Теперь можно проверить, устранили ли проблему вновь добавленные разрешения.
bill устанавливает маску umask в значение 0002, удаляет предыдущий провероч-
ный файл и создает новый проверочный файл и каталог:
[bill@linuxbox ~]$ umask 0002
[bill@linuxbox ~]$ rm /usr/local/share/Music/test_file
[bill@linuxbox ~]$ > /usr/local/share/Music/test_file
[bill@linuxbox ~]$ mkdir /usr/local/share/Music/test_dir
[bill@linuxbox ~]$ ls -l /usr/local/share/Music
drwxrwsr-x 2 bill
music 4096 2018-03-24 20:24 test_dir
-rw-rw-r-- 1 bill
music
0 2018-03-24 20:22 test_file
[bill@linuxbox ~]$
И файл и каталог теперь созданы с правильными правами доступа, позволяющи-
ми всем членам группы music создавать файлы и каталоги внутри каталога Music.
Осталась только проблема с маской umask. Дело в том, что установленная маска
действует лишь до конца сеанса и сбрасывается по его завершении. Как решить проблему мы  узнаем в последующих главах.

### Изменение своего пароля

Для установки и из-
менения пароля используется команда passwd. Она имеет следующий синтаксис:

passwd [пользователь]

Чтобы изменить свой пароль, просто введите команду passwd. Вам будет предло-
жено ввести старый, а затем новый пароль:

![alt text](pictures/image-157.png)


Заметим, что если будет предложен слабый пароль, система скажет об этом пользователю.

При наличии привилегий суперпользователя можно передать команде passwd аргумент с именем пользователя, чтобы установить пароль для этого пользователя.
Суперпользователю доступна также возможность блокировки учетных записей,
установки времени действия пароля и многое другое. За подробностями обращайтесь к странице справочного руководства (man) для команды passwd.

## Глава 10. Процессы


Современные операционные системы обычно являются многозадачными, в том
смысле, что создают иллюзию одновременного решения множества задач, быстро
переключаясь с выполнения одной программы на другую. Ядро Linux управляет
всем этим посредством процессов. Именно с помощью процессов Linux организует
приостановку программ в ожидании, пока наступит их очередь использовать процессор.

### Как действует процесс

В момент запуска системы ядро инициирует выполнение нескольких собственных
задач в виде процессов и запускает программу с названием init. В свою очередь init выполняет последовательность сценариев командной оболочки (находятся
в /etc), называемых сценариями начальной загрузки (init scripts), которые запускают все системные службы. Многие из этих служб реализованы как программы-
демоны (daemon programs), то есть программы, действующие в фоновом режиме
и выполняющие свою работу без участия пользователя. Поэтому, даже в отсутствие зарегистрированных пользователей, система выполняет определенные служебные процедуры.

Принцип, по которому программа может запускать другие программы, выражается правилом: родительский процесс запускает дочерний процесс.
Ядро хранит информацию обо всех процессах, чтобы упорядочить их работу. Например, каждому процессу присваивается номер, который называют идентификатором процесса (Process ID, PID). Идентификаторы процессов присваиваются в порядке возрастания, при этом процесс init всегда получает идентификатор PID 1. Ядро также следит за памятью, выделенной каждому процессу, и за готовностью процессов возобновить выполнение. Подобно файлам, процессы также имеют идентификаторы владельца и пользователя, эффективный (или действующий) идентификатор пользователя и т. д.

### Просмотр списка процессов

Чаще всего для просмотра списка процессов используется команда ps. Программа ps имеет множество параметров, но в самом простейшем случае она используется следующим образом:

![alt text](pictures/image-161.png)

В этом примере команда вывела список с двумя процессами: процесс 4228 и процесс
6711 — программы bash и ps соответственно. Как можно заметить, по умолчанию ps
выводит не очень много информации, только процессы, связанные с текущим сеансом.
Рассмотрим основные поля в выводе команды ps. Поле TTY — это сокращение от teletype (телетайп), оно содержит информацию об управляющем терминале процесса. 
Историческая справка.

<i>Телетайп — это электромеханический телеграфный аппарат с клавиатурой, похожей на пишущую машинку, предназначенный для передачи текстовых сообщений между двумя абонентами по простейшему электрическому каналу (обычно по паре проводов). Он автоматически печатает принимаемые сообщения буквами, что позволяло обмениваться текстом на расстоянии.
Изначально телетайпы были широко применимы в телеграфных сетях и в качестве терминалов для вычислительной техники. Позже появились полностью электронные модели с дисплеями вместо печатающих механизмов.
В Linux сохранился текстовый редактор ed, который имеет историческую и конфептуальную связь с телетайпом. Он был разработан в начале 1970-х годов, когда мониторов с экраном ещё не существовало, и основным средством ввода-вывода в компьютерных системах были именно телетайпы — электромеханические устройства, похожие на печатные машинки, которые печатали ввод и вывод на бумаге.
Из-за ограничений телетайпов (отсутствие курсора, медленная печать, невозможность визуального редактирования текста на экране) редактор ed был создан как строчный (линейный) редактор, где редактирование происходило построчно через команды, а не визуально. Такой подход был удобен именно для работы с телетайпами, поскольку перемещать курсор или выделять текст на бумажной ленте невозможно, и текст вводился и выводился последовательно.

Таким образом:

* ed унаследовал концепцию работы с текстом, адаптированную под телетайп — построчное редактирование через команды.

* Интерфейс ed минималистичен, без визуальной обратной связи, что отражает ограничения телетайпов.

* Многие идеи ed пришли из более раннего редактора QED, который тоже создавался для систем с телетайпами.

По мере появления экранных терминалов и видеодисплеев появились более удобные визуальные редакторы (например, ex и vi), но ed остаётся частью стандартного набора UNIX/Linux как наследник эпохи телетайпов.</i>

В Unix в этом поле выводится тип терминала. Поле TIME содержит объем процессорного времени, потребленного процессом. Как видите, ни один из процессов не является слишком обременительным для компьютера. Если добавить параметр x, можно получить более богатую информацию о происходящем в системе:

![alt text](pictures/image-162.png)


Дополнительный параметр x (обратите внимание на отсутствие дефиса) сообщает
команде ps, что та должна вывести все процессы, независимо от того, какие терминалы (если таковые имеются) управляют ими. Символ ? в поле TTY указывает на
отсутствие управляющего терминала. Таким образом, параметр x позволяет увидеть все процессы в системе, которыми мы владеем.
Так как в системе одновременно выполняется множество процессов, ps производит довольно длинные списки. Часто бывает полезно передать вывод ps команде
less через конвейер, чтобы его проще было просматривать. Некоторые комбинации параметров приводят к выводу очень длинных строк, поэтому нелишним будет также распахнуть окно эмулятора терминала на весь экран.

В этом примере в выводе появился новый столбец — STAT. Название STAT — это
сокращение от state (состояние), столбец содержит информацию о текущем состоянии процесса, как показано в таблице ниже.

![alt text](pictures/image-163.png)

![alt text](pictures/image-164.png)

### Зомби процессы

Каждая программа, которая выполняется в Linux, - это системный процесс, у которого есть свой идентификатор. Каждый процесс может запускать дочерние процессы с помощью функции fork. Такие процессы остаются под контролем родительского процесса и не могут быть завершены без его ведома. Если один из дочерних процессов всё же завершился, а его родительский процесс не смог получить об этом информацию, то такой дочерний процесс становится зомби.

Зомби процессы Linux не выполняются и убить их нельзя, даже с помощью sigkill, они продолжают висеть в памяти, пока не будет завершён их родительский процесс.

Посмотреть такие процессы можно с помощью утилиты ps, здесь они отмечаются как defunct: <br>

ps aux | grep defunct <br>

![alt text](pictures/image-168.png)

Если вы попытаетесь убить такой процесс с помощью сигнала KILL, то ничего не выйдет.

![alt text](pictures/image-169.png)


Чтобы его завершить, нужно найти "родителя" этого процесса. Для этого используйте команду:

ps -xal | grep defunct

![alt text](pictures/image-170.png)


Здесь идентификатор родительского процесса находится в четвёртой колонке (PPID). Теперь мы можем послать ему сигнал завершения, и такого процесса в системе больше не будет.

Еще одна популярная комбинация параметров — aux (без дефиса в начале). Она
позволяет получить еще больше информации:

![alt text](pictures/image-165.png)


Эта комбинация параметров выводит процессы, принадлежащие всем пользователям. При использовании параметров без начального дефиса команда действует «в стиле BSD». Linux-версия команды ps может имитировать поведение программы ps, используемой в некоторых реализациях Unix. С помощью этих параметров мы получили дополнительные столбцы, описанные в таблице ниже:

![alt text](pictures/image-166.png)

![alt text](pictures/image-167.png)

Существует ещё одна команда просмотра процессов, как мне кажется, она более удобная, чем ps.

ss -tlp


### Справка по BSD системам

FreeBSD — это свободная операционная система семейства UNIX, происходящая от BSD (Berkeley Software Distribution), разработанной в Калифорнийском университете в Беркли. FreeBSD представляет собой цельную систему, где ядро, драйверы и базовые утилиты разрабатываются и поддерживаются в едином проекте, в отличие от Linux, где ядро и пользовательское пространство создаются разными командами и потом объединяются в дистрибутивы.

Основные отличия FreeBSD от Linux:

* Происхождение и архитектура: FreeBSD — потомок UNIX через BSD, Linux — это самостоятельное ядро, вдохновлённое UNIX, но не являющееся его прямым наследником

* Лицензия: FreeBSD использует более либеральную BSD-лицензию, которая позволяет использовать код в проприетарных продуктах без обязательного раскрытия исходников. Linux распространяется под GPL, требующей открытости кода при распространении изменений

* Целостность системы: FreeBSD разрабатывается как единое целое — ядро и базовые утилиты идут из одного источника, что обеспечивает высокую согласованность. Linux — это ядро, а пользовательские программы и утилиты собираются из разных проектов и объединяются в дистрибутивы

* Особенности и инструменты: FreeBSD предлагает технологии, такие как ZFS — продвинутая файловая система с поддержкой снимков и восстановления, Jails — механизм лёгкой виртуализации и изоляции, pf — мощный пакетный фильтр, а также DTrace для отладки и профилирования системы в реальном времени

* Поддержка оборудования и сообщества: Linux поддерживает гораздо больше аппаратных платформ и имеет более широкое сообщество пользователей и разработчиков, что делает его более универсальным для настольных и мобильных устройств. FreeBSD чаще используется для серверов, сетевых решений и встраиваемых систем

* Управление пакетами и обновлениями: В FreeBSD используется система портов и пакетов, позволяющая гибко устанавливать и обновлять ПО, но подход отличается от популярных менеджеров пакетов Linux-дистрибутивов.

В итоге FreeBSD ценится за стабильность, согласованность системы, продвинутые сетевые возможности и более свободную лицензию, в то время как Linux более универсален, имеет более широкую поддержку оборудования и разнообразие дистрибутивов.

### Просмотр состояния процессов в динамике с помощью top

Команда ps сообщает массу информации о том, что делается в компьютере, но она
дает только мгновенный снимок, то есть возвращаемая ею информация действи-
тельна лишь на момент вызова команды. Чтобы увидеть работу компьютера в ди-
намике, воспользуемся командой top:

![alt text](pictures/image-171.png)


Программа top постоянно обновляет информацию о процессах (по умолчанию
с периодом, равным 3 секундам), чтобы показать их активность с течением времени. Имя программы top отражает тот факт, что она используется для просмотра
«топа» (наиболее активных) процессов в системе. Вывод команды top делится на
две части: сводная информация о системе и таблица процессов, отсортированных
по потреблению ими процессора. Раздел со сводной информацией содержит массу интересных сведений. Описание выводимой в этом разделе информации приводится в таблице ниже.

![alt text](pictures/image-172.png)

### Управление процессами


Теперь, когда мы можем видеть процессы и наблюдать за ними, можно приступать
к управлению ими. Перед вами программа xlogo — это демонстрационная программа, поставляемая в составе X Window System (механизм создания графического изображения на дисплее), которая просто отображает окно с логотипом X. Для начала давайте познакомимся с объектом экспериментов:

![alt text](pictures/image-173.png)


Заметили ли вы, что командная оболочка не вывела приглашения к вводу после выполнения команды? Это объясняется тем, что командная оболочка ждет, пока
программа завершится. То же самое происходило со всеми программами, которые
мы запускали до сих пор. Если закрыть окно xlogo, оболочка выведет приглашение к вводу.


### Прерывание процесса

Давайте понаблюдаем, что происходит после запуска xlogo. Сначала введите
коман­ду xlogo и убедитесь, что программа работает. Затем вернитесь в окно терминала и нажмите комбинацию CTRL+C.

[me@linuxbox ~]$ xlogo
[me@linuxbox ~]$

Комбинация CTRL+C в терминале прерывает выполнение программы. Фактически мы вежливо попросили программу завершиться. После нажатия CTRL+C окно
xlogo закроется и командная оболочка выведет приглашение к вводу.
Таким способом можно прервать выполнение многих (но не всех) программ ко-
мандной строки.

### Перевод процессов в фоновый режим

Представьте, что нам потребовалось вернуться в командную оболочку, не прерывая выполнения программы xlogo. Мы можем сделать это, переведя программу
в фоновый режим работы. Считайте, что терминал имеет передний план (то, что
видно на поверхности, например приглашение к вводу) и задний план (фон, то, что
скрыто под поверхностью). Чтобы запустить программу сразу в фоновом режиме, нужно добавить в конец команды амперсанд (&):

[me@linuxbox ~]$ xlogo &
[1] 28236
[me@linuxbox ~]$

После ввода такой команды на экране появится окно xlogo, а командная оболочка
вернется в приглашение к вводу, но перед этим выведет таинственные числа. Это
сообщение является частью механизма управления заданиями (job control). Таким
способом командная оболочка сообщает, что мы запустили задание с номером 1
([1]) и оно получило идентификатор процесса PID 28236. Если теперь выполнить
команду ps, можно увидеть этот процесс:

[me@linuxbox ~]$ ps
PID TTY
TIME CMD
10603 pts/1
00:00:00 bash
28236 pts/1
00:00:00 xlogo
28239 pts/1
00:00:00 ps


Механизм управления заданиями также дает возможность вывести список заданий, запущенных в терминале. Этот список можно получить командой jobs:

[me@linuxbox ~]$ jobs
[1]+ Running
xlogo &

Результаты показывают, что у нас имеется одно выполняющееся задание с номером 1, которое было запущено командой xlogo &.


### Возврат процесса на передний план

Процесс в фоновом режиме не получает ввод с клавиатуры, в том числе не видит
попыток прервать его комбинацией CTRL+C. Вернуть процесс на передний план
можно командой fg, как в следующем примере:

[me@linuxbox ~]$ jobs
[1]+ Running
[me@linuxbox ~]$ fg %1
xlogo
xlogo &

За командой fg должен следовать знак процента и номер задания (эта комбинация
называется спецификатором задания, или jobspec). Если имеется только одно фоновое задание, спецификатор можно опустить. Теперь завершим xlogo вводом CTRL+C.


### Приостановка процесса

Иногда необходимо приостановить процесс на время, не завершая его. Это часто
делается с целью перевести процесс переднего плана в фоновый режим. Чтобы
приостановить процесс переднего плана, используйте комбинацию CTRL+Z. Давай-
те попробуем. В командной строке введите команду xlogo, нажмите ENTER, а затем
комбинацию CTRL+Z:

[me@linuxbox ~]$ xlogo
[1]+ Stopped
[me@linuxbox ~]$
xlogo

После приостановки xlogo убедимся, что программа действительно приостанови-
лась, для этого попытаемся изменить размер окна xlogo. Увы, программа никак не
реагирует на наши действия. Далее можно или вернуть программу на передний
план командой fg, или перевести ее в фоновый режим командой bg:

[me@linuxbox ~]$ bg %1
[1]+ xlogo &
[me@linuxbox ~]$

Так же как в случае с командой fg, спецификатор задания можно опустить, если
имеется только одно задание. Возможность перевода в фоновый режим полезна и в том случае, если при запуске программы с графическим интерфейсом из командной строки вы забыли добавить в конец команды символ &.

### Сигналы

Команда kill используется для завершения процессов. Она позволяет принудительно завершить выполнение вышедшей из-под контроля программы, отвергающей любые другие попытки закрыть ее. Например:

[me@linuxbox ~]$ xlogo &
[1] 28401
[me@linuxbox ~]$ kill 28401
[1]+ Terminated
xlogo

Здесь мы сначала запустили xlogo в фоновом режиме. В ответ командная оболочка вывела номер задания и идентификатор фонового процесса (PID). Затем
вызвали команду kill, которой передали PID процесса для завершения. Процесс можно также идентифицировать, указав спецификатор задания (например, %1)
вместо PID.
Хотя все выглядит достаточно просто, в действительности команда kill не про-
сто «убивает» (kill) процессы — она посылает им сигналы. Сигналы — один из
нескольких способов, которыми операционная система общается с программа-
ми. Мы уже видели сигналы в действии на примере использования комбинаций
клавиш CTRL+C и CTRL+Z. Когда терминал принимает одну из этих комбинаций,
он посылает сигнал программе на переднем плане. В случае нажатия CTRL+C программе посылается сигнал INT (Interrupt — прервать); в случае нажатия CTRL+Z посылается сигнал TSTP (Terminal Stop — сигнал «стоп» с клавиатуры). Программы
в свою очередь принимают сигналы и могут реагировать на них. Эта возможность
позволяет программе выполнить некоторые операции, например, сохранить промежуточные результаты при получении сигнала на завершение.

### Отправка сигналов процессам командой kill
Наиболее типичный синтаксис команды kill имеет следующий вид:
kill [-сигнал] PID...

Если сигнал явно не указан в команде, по умолчанию посылается сигнал TERM
(terminate — завершить). Команда kill чаще всего используется для посылки сигналов, перечисленных в таблице ниже.

![alt text](pictures/image-174.png)

![alt text](pictures/image-175.png)


Поэкспериментируем с командой kill:
[me@linuxbox ~]$ xlogo &
[1] 13546
[me@linuxbox ~]$ kill -1 13546
[1]+ Hangup
xlogo
Здесь мы запустили программу xlogo в фоновом режиме и затем с помощью ко-
манды kill послали ей сигнал HUP. Программа xlogo завершилась, и командная
оболочка сообщила, что фоновый процесс принял сигнал разрыва связи. Иногда
необходимо нажать клавишу ENTER пару раз, чтобы увидеть сообщение. Обратите
внимание, что сигнал можно указать по номеру или по имени, включая имена сигналов, начинающиеся с префикса SIG:

[me@linuxbox ~]$ xlogo &
[1] 13601
[me@linuxbox ~]$ kill -INT 13601
[1]+ Interrupt
xlogo
[me@linuxbox ~]$ xlogo &
[1] 13608
[me@linuxbox ~]$ kill -SIGINT 13608
[1]+ Interrupt
xlogo


Процессы, подобно файлам, имеют владельцев, и чтобы послать сигнал процессу
командой kill, вы должны быть владельцем процесса (или суперпользователем). В таблице ниже приведены другие часто используемые сигналы.

![alt text](pictures/image-176.png)

Весь список можно просмотреть, выполнив команду kill -l.


### Отправка сигналов нескольким процессам с помощью killall

Кроме того, существует возможность с помощью команды killall послать сигнал
сразу нескольким процессам, соответствующим указанной программе или имени
пользователя. Она имеет следующий синтаксис:

killall [-u пользователь] [-сигнал] имя...
Для демонстрации запустим пару экземпляров программы xlogo и затем завер-
шим их:
[me@linuxbox ~]$ xlogo &
[1] 18801
[me@linuxbox ~]$ xlogo &
[2] 18802

[me@linuxbox ~]$ killall xlogo
[1]- Terminated
xlogo
[2]+ Terminated
xlogo

Помните: так же как при использовании команды kill, вы должны обладать при-
вилегиями суперпользователя, чтобы посылать сигналы процессам, которыми не
владеете.


### Остановка системы
Для остановки системы перед выключением электропитания требуется по по-
рядку завершить все выполняющиеся процессы, а также выполнить некоторые
важные служебные операции (например, синхронизировать все смонтированные
файловые системы). Эту задачу решают четыре команды:

sudo halt             # остановить систему (не всегда выключает питание)
sudo poweroff         # выключить систему и питание
sudo reboot           # перезагрузить систему
sudo shutdown -h now  # выключить систему сейчас
sudo shutdown -r now  # перезагрузить систему сейчас


Команде shutdown можно указать, какое действие она должна выполнить (остановить, выключить электропитание или перезагрузить), и время задержки перед действием. Чаще она используется для остановки системы:

[me@linuxbox ~]$ sudo shutdown -h now
и перезагрузки:
[me@linuxbox ~]$ sudo shutdown -r now


В таблице ниже приведены другие команды управления процессами. 

![alt text](pictures/image-177.png)