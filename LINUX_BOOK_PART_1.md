## Содержание

### Часть I Командная оболочка
- [Глава 1. Что такое командная оболочка ](#глава-1-что-такое-командная-оболочка)
- [Глава 2. Навигация](#глава-2-навигация)
- [Глава 3. Исследование системы](#глава-3-исследование-системы)
- [Глава 4. Операции с файлами и каталогами](#глава-4-операции-с-файлами-и-каталогами)
- [Глава 5. Работа с командами](#глава-5-работа-с-командами)


## Глава 1. Что такое командная оболочка

<b>Командная оболочка</b> — это программа, которая принимает команды, введенные с клавиатуры, и передает их операционной системе для выполнения.
При запуске терминала появляется приглашение к вводу вида _user_name@computer_name_, за которым следует имя текущего каталога.
Если последний символ в приглашении - знак решетки (#), а не доллар ($), то это означает, что сеанс проходит в режиме суперпользователя.

_Пример: пользователь с обычными правами_ <br>
![alt text](pictures/image.png) <br>
_Пример: переключение в сеанс с правами root (sudo -i имитирует полноценный вход рута с окружением рута, а sudo su сохраняет окружение текущего пользователя)_<br>
![alt text](pictures/image-1.png)

#### Копирование текста
В терминале копирование производится с помощью выделения текста, нажатия правой кнопки мыши, вставка также - правая кнопка мыши (ещё можно с помощью CTRL+SHIFT+C)

#### История команд
Для вызова истории необходимо нажать клавишу со стрелкой вверх, стрелки влево и вправо позволяют менять позицию курсора в команде, тем самым редактировать ввод.

#### Некоторые простые команды

_Вывод текущей даты и времени_ <br>
![alt text](pictures/image-2.png)

_Вывод календаря текущего месяца (по умолчанию не установлен, sudo apt install ncal)_ <br>
![alt text](pictures/image-3.png)

_Объем свободного пространства на дисках (ключ -h дает удобочитаемый формат)_ <br>
![alt text](pictures/image-4.png)

_Объем свободного пространства в ОЗУ (ключ -h дает удобочитаемый формат)_<br>
![alt text](pictures/image-5.png)


_Завершение сеанса работы с терминалом: команда exit_ <br>


## Глава 2. Навигация

Первый каталог в файловой системе называется _корневым каталогом_. Корневой каталог содержит файлы и подкаталоги, которые в свою очередь также содержат файлы и каталоги, и т. д. 
В отличие от Windows, где для каждого устройства хранения создается отдельная файловая система, в Linux всегда имеется только одна файловая система, независимо от числа дисков, подключенных к компьютеру. Устройства хранения подключаются (или, как принято говорить, монтируются) к дереву файловой системы. 
Родительский каталог - вышележащий каталог от текущего местоположения в файловой системе.
Текущий рабочий каталог - это каталог, где мы находимся в данный момент.

_Вывод названия текущего рабочего каталога_ <br>
![alt text](pictures/image-6.png) <br>

Сразу после входа в систему (или запуска сеанса в эмуляторе терминала) текущим рабочим каталогом становится наш домашний каталог. Каждый пользователь имеет свой домашний каталог, который является единственным, где пользователю позволено осуществлять запись в файлы, когда он действует с привилегиями обычного пользователя.

### Вывод содержимого каталога

![alt text](pictures/image-7.png)<br>

### Смена текущего рабочего каталога

Абсолютный путь

Абсолютный путь начинается с корневого каталога и перечисляет ветви дерева, отделяющие корень от желаемого каталога или файла. <br>
![alt text](pictures/image-8.png)<br>

Относительный путь

Относительный путь начинается в рабочем каталоге. Для обозначения относительных позиций в дереве файловой системы используется
пара специальных символов: . (точка) и .. (точка-точка). Символ . (точка) обозначает рабочий каталог, а символ .. (точка-точка) обозначает каталог, родительский по отношению к рабочему. <br>
![alt text](pictures/image-9.png) <br>

Сокращенные варианты команды cd

| Команда                | Результат |
|------------------------|-----------|
| cd                     | Сменить рабочий каталог на домашний |
| cd -                   | Сменить рабочий каталог на предыдущий рабочий каталог |
| cd&nbsp;~username          | Сменить рабочий каталог на домашний каталог пользователя username. Например, cd ~olga выполнит переход в домашний каталог пользователя olga |

### Особенности имен файлов в Linux

* Файлы, имена которых начинаются с точки, считаются скрытыми. Это означает, что команда ls не будет выводить их, если не вызвать ее с ключом -a. <br>
![alt text](pictures/image-10.png) <br>
* Linux различает регистр символов в именах файлов и командах. Файлы с именами File1 и file1 — это разные файлы. <br>
* Хотя Linux поддерживает длинные имена файлов с пробелами и знаками пунктуации, старайтесь не использовать в именах файлов другие знаки пунктуации,кроме точки, дефиса и подчеркивания. И самое главное, не используйте пробелы в именах файлов. Если необходимо отделить друг от друга слова в имени файла, используйте символы подчеркивания. <br>
* Linux различает регистр символов в именах файлов и командах. Файлы с именами File1 и file1 — это разные файлы. <br>
* В Linux не поддерживается понятие «расширения файла», как в некоторых других операционных системах. Вы можете давать своим файлам любые имена. Тип и/или назначение файла определяется другими средствами. <br>

## Глава 3. Исследование системы

### Возможности команды ls

Можно явно указать каталог, содержимое которого требуется вывести. <br>
Вывод содержимого домашнего каталога, а также /usr
![alt text](pictures/image-11.png)<br>
Изменение формата вывода: команда ls -l предоставляет длинный (ключ -l --->> long) форма вывода <br>
![alt text](pictures/image-12.png) <br>

### Аргументы команды ls

| Параметр | Длинный параметр | Описание | Пример|
|-------------|-------------|-------------|-------------|
| -a       | --all | Список всех (all) файлов, включая скрытые  | ![alt text](pictures/image-13.png)  |
| -A | --almost-all | Действует подобно параметру -a, но не выводит каталоги . (текущий рабочий каталог) и .. (родительский каталог) | ![alt text](pictures/image-14.png)  |
| -d | --directory  | Информация о каталоге, а не о его содержимом. Используйте этот параметр в сочетании с параметром -l, чтобы получить дополнительную информацию о каталоге, а не о его содержимом. | ![alt text](pictures/image-15.png)  |
| -F   | --classify   | Добавляет в конец каждого имени символ-индикатор, например, прямой слеш, если это имя каталога  | ![alt text](pictures/image-16.png) |
| -h | --human-readable  | При использовании ключа -l  отображает размеры файлов не в байтах, а в величинах с единицами измерения | ![alt text](pictures/image-17.png)  |
| -l  |   | Полное описание файлов  | ![alt text](pictures/image-18.png)  |
| -r  | --reverse | Выводит результаты в обратном порядке. Обычно команда ls выводит результаты в алфавитном порядке  | ![alt text](pictures/image-19.png) |
| -S  | --size  | Сортировка по размеру | ![alt text](pictures/image-20.png) |
| -t  |  | Сортировать по времени последнего изменения  | ![alt text](pictures/image-21.png)  |

### Особенности вывода ls -l

Перед вами вывод команды ls -l <br>

![alt text](pictures/image-22.png) <br>

Рассмотрим форматы вывода и их назначения

| Формат | Назначение | 
|-------------|-------------|
| -rw-r-r--   | Права доступа к файлу. Первый символ указывает тип файла. Например, символом дефиса обозначаются обычные файлы,а символом d — каталоги. Следующие три символа сообщают о правах доступа для владельца файла, следующие три — для членов группы, которой принадлежит файл, и последние три — для всех остальных.| 
| 1  | Число жестких ссылок на файл.  | 
| olga | Имя пользователя, владеющего файлом | 
| olga  | Имя группы, владеющей файлом | 
| 4096 | Размер файла в байтах  | 
| May 12 17:25  | Дата и время последнего изменения файла  |
| java.txt | Название файла  | 

### Определение типов файлов командой file

Имена файлов в Linux не обязаны отражать тип содержимого файлов. Например, увидев имя файла picture.jpg, можно предположить, что он содержит изображение в формате JPEG, но в Linux такие предположения могут не оправдываться. 
Чтобы точно понять, что за файл перед вами, даже если у него нет расширения, выполните команду:
![alt text](pictures/image-23.png) <br>
В результате вы получите описание того, какой перед вами тип файла. Важно заметить, что одна из известных идей в Linux, гласит: «Все сущее есть файл». 

### Просмотр содержимого файлов командой less

Команда less служит для просмотра текстовых файлов с прокруткой. 

После запуска программа less позволяет прокручивать текстовый файл взад и вперед. Например, просмотреть содержимое файла со всеми известными системе учетными записями пользователей можно с помощью следующей команды:

less /etc/passwd

### Управление с клавиатуры для команды less

![alt text](pictures/image-24.png)
![alt text](pictures/image-25.png)

Если по ошибке вы попробовали просмотреть содержимое нетекстового файла и полностью нарушили нормальную работу окна терминала, вы можете вернуть его в исходное состояние, выполнив команду reset.

Команда less создавалась как улучшенная замена более ранней команды more. Ее имя — это игра слов «less is more» (меньше значит больше). В отличие от команды more, которая может листать страницы только вперед, less способна листать текст в обоих направлениях, вперед и назад, и имеет множество других
особенностей.

### Файловая система Linux

Рассмотрим некоторые основные каталоги файловой системы Linux и их предназначение

![alt text](pictures/image-26.png)
![alt text](pictures/image-27.png)
![alt text](pictures/image-28.png)

## Глава 4. Операции с файлами и каталогами

Поскольку имена файлов используются в консоли повсеместно, она поддерживает специальные символы, помогающие быстро определять группы имен файлов. Эти специальные символы называют wildcards. 

### Wildcards

![alt text](pictures/image-29.png)

### Классы символов

![alt text](pictures/image-30.png)

### Примеры использования wildcards 

![alt text](pictures/image-31.png)
![alt text](pictures/image-32.png)

### Создание каталогов

Команда mkdir позволяет создавать каталоги <br>

![alt text](pictures/image-33.png)

Если использовать ключ -p, то создаются вложенные каталоги. В примере создается test3, внутри которого находится test4. <br>

![alt text](pictures/image-34.png)

###  Копирование файлов и каталогов

Команда cp позволяет копировать файлы и каталоги <br>

Скопируем файл test в каталог test1 <br>

![alt text](pictures/image-35.png)

### Некоторые ключи команды cp

![alt text](pictures/image-36.png)

### Примеры использования команды cp

![alt text](pictures/image-37.png)

Скопируем файл с учетными записями пользователей в текущий каталог <br>

![alt text](pictures/image-38.png)

Точка в конце - это обозначение текущего каталога  <br>

Если использовать ключ -v, то мы увидим сообщение, что операция была выполнена. <br>

![alt text](pictures/image-39.png)

Обратите внимание, что cp перезаписала первую копию без каких-либо предупреждений. Это как раз тот случай,когда cp полагает, что вы знаете, что делаете. Чтобы вывести предупреждение, включите параметр -i:


![alt text](pictures/image-40.png)

Если в ответ на запрос ввести y, команда перезапишет существующий файл; если ввести любой другой символ (например, n), cp оставит прежнюю копию файла нетронутой.

### Перемещение и переименование файлов с помощью команды mv

Команда mv выполняет операции перемещения и переименования файлов в зависимости от особенностей использования. В любом случае исходный файл исчезает после операции. Команда mv используется почти так же, как команда cp: <br>

mv item1 item2 <br>

перемещает или переименовывает файл или каталог item1 в item2. <br>

mv элемент... каталог <br>

перемещает один или более элементов из одного каталога в другой. <br>

### Некоторые ключи команды mv 

![alt text](pictures/image-41.png)


### Примеры использования команды mv 

![alt text](pictures/image-42.png)


### Удаление файлов и каталогов с помощью команды rm

Команда rm используется для удаления (remove) файлов и каталогов, например: <br>
rm элемент <br>
где элемент — это один или несколько файлов или каталогов <br>

### Некоторые ключи команды rm

![alt text](pictures/image-43.png)

### Примеры использования команды rm

![alt text](pictures/image-44.png)


<b>БУДЬТЕ ОСТОРОЖНЫ С КОМАНДОЙ RM!</b>
Linux не имеет команды, отменяющей удаление. Если вы что-то удалили командой rm, это исчезнет навсегда. Linux считает вас достаточно ответственным человеком, отдающим себе отчет в своих действиях. Будьте особенно осторожны с wildcards. Рассмотрим следующий классический пример. Допустим, вы захотели удалить все файлы HTML в каталоге. <br>
Для этого вы вводите команду: <br>
rm *.html <br>
которая сделает именно то, что вам нужно, но если вы случайно вставите пробел
между * и .html, как в следующей команде: <br>
rm * .html <br>
rm удалит все файлы в каталоге и затем сообщит, что не нашла файла .html.
Полезный совет: всякий раз, используя групповые символы с командой rm (по-
мимо внимательной проверки ввода!), проверьте сначала аргумент с групповым
символом с командой ls. Это позволит увидеть, какие файлы будут удалены. За-
тем нажмите клавишу со стрелкой вверх, чтобы восстановить команду из истории,
и замените ls на rm.

### Символические и жесткие ссылки

#### Символические ссылки

Просматривая содержимое каталогов (например, /lib), нередко можно увидеть
такие записи: <br>
lrwxrwxrwx 1 root root 11 2018-08-11 07:34 libc.so.6 -> libc-2.6.so

Обратили внимание на первую букву l и на присутствие двух имен файлов в конце? Это специальный файл, который называется символической ссылкой (иногда их называют мягкими ссылками или, на жаргоне, симлинками). В большинстве Unix-подобных систем можно дать одному и тому же файлу несколько имен. Даже
притом, что на данный момент ценность такого приема может быть не очевидна, в действительности это очень удобная возможность.

Вообразите следующий сценарий: программе требуется некий разделяемый ресурс (например, библиотека), хранящийся в файле с именем «foo», но номер версии «foo» меняется очень часто. Было бы хорошо включить номер версии в имя файла, чтобы администратор или другое заинтересованное лицо могли видеть, какая версия «foo» установлена. И здесь возникает проблема. Если изменить имя разделяемого ресурса, нам придется проверять каждую программу, использующую этот ресурс, и изменять в ней имя ресурса на новое после установки новой версии ресурса. Если честно, такая перспектива не выглядит привлекательной.

Символические ссылки помогут спасти положение. Допустим, мы установили «foo» версии 2.6 с именем файла «foo-2.6» и затем создали символическую ссылку с простым именем «foo», указывающую на ресурс «foo-2.6». То есть когда программа откроет файл «foo», в действительности она откроет файл «foo-2.6». И все будут счастливы. Программы, полагающиеся на имя «foo», найдут нужный файл, а мы сможем увидеть фактическую версию ресурса. Когда придет время обновить ресурс до версии «foo-2.7», мы просто добавим файл в систему, удалим символическую ссылку «foo» и создадим новую символическую ссылку, указывающую на новую версию. Такой подход не только решает проблему обновления версий, но также позволяет сохранить на компьютере обе версии ресурса. Представьте, что в версии «foo-2.7» обнаружилась ошибка (ох уж эти разработчики!) и нужно вернуть старую версию. В этом случае достаточно просто вновь удалить символическую ссылку, указывающую на новую версию, и создать новую символическую ссылку, указывающую на старую версию. Запись выше (получена в каталоге /lib в системе Fedora) соответствует символи-
ческой ссылке с именем libc.so.6, указывающей на файл разделяемой библиотеки с именем libc-2.6.so. Это означает, что программа, ищущая libc.so.6, фактически получит файл libc-2.6.so. 


#### Жесткие ссылки

Жесткие ссылки также позволяют присвоить одному файлу несколько имен, но они действуют иначе. Жесткие ссылки — это первоначальный способ создания ссылок в Unix; символические ссылки — более позднее изобретение. По умолчанию каждый файл имеет одну жесткую ссылку, определяющую его имя. Создавая жесткую ссылку, мы создаем дополнительную запись в каталоге для файла. Жесткие ссылки имеют два важных ограничения. 
* Жесткая ссылка не может указывать на файл за пределами собственной файловой системы. Это означает, что ссылка не может указывать на файл, находящийся в другом разделе диска.
* Жесткая ссылка не может указывать на каталог.
Жесткая ссылка неотличима от самого файла. В отличие от символических ссылок, при выводе списка с содержимым каталогов жесткие ссылки никак не выделяются. При удалении жесткой ссылки удаляется только сама ссылка, а файл остается на месте (то есть пространство, занимаемое файлом, не освобождается), пока не будут удалены все жесткие ссылки на файл.

_Важно!_

Символические ссылки были придуманы с целью преодолеть ограничения жестких ссылок. Когда создается символическая ссылка, в действительности создается файл особого типа, содержащий текстовый указатель на файл или каталог. В некотором отношении они действуют подобно ярлыкам в Windows, но, конечно же,
появились задолго до ярлыков Windows. Файл, на который указывает символическая ссылка, и сама символическая ссылка почти неотличимы друг от друга. Например, если попытаться что-то записать в символическую ссылку, запись будет выполнена в файл, на который она указывает. Однако при удалении символической ссылки удаляется только символическая ссылка, но не файл. Если удалить файл до того, как будет удалена символическая ссылка, ссылка останется на месте, но будет указывать в никуда. О таких ссылках говорят, что они «битые». Во многих реализациях команда ls выделяет битые ссылки цветом, например красным, чтобы обратить на них внимание.

### Создание жестких ссылок

![alt text](pictures/image-45.png)

Посмотрим, что содержит наш каталог <br>

![alt text](pictures/image-46.png)

Прежде всего обратим внимание на второе поле в записях файлов test и test_hard_ln, мы видим число 2 - это число ссылок. Файл всегда имеет хотя бы однк жесткую ссылку, потому что имя файла определяется ссылкой. Но как же нам убедиться, что это один и тот же файл ?
Создавая жесткую ссылку, мы фактически создаем дополнительный раздел с именем, ссылающийся на тот же раздел с данными. Цепочку дисковых блоков система присваивает тому, что называется индексным узлом (inode), который затем присваивается разделу с именем. То есть каждая жесткая ссылка ссылается на определенный индексный узел с содержимым файла.
Команда ls может извлекать эту информацию. Для этого ее нужно вызвать с параметром -i:

![alt text](pictures/image-47.png)

Как видно, значение inode у исходного файла и ссылки одинаковое - они ссылаются на один и тот же объект.

### Создание символических ссылок

Они создаются почти также, как и жесткие, добавляется лишь ключ -s. 

![alt text](pictures/image-48.png)

Не забывайте, что, создавая символическую ссылку, мы фактически определяем текст, описывающий местоположение целевого файла относительно символической ссылки. В этом легко убедиться, если взглянуть на вывод команды ls:

![alt text](pictures/image-49.png)

Обратите внимание на размер символической ссылки, равный 4, - это число символов в строке test, а не размер файла, на который он указывает. 
При создании символических ссылок можно также указывать абсолютные пути, и помимо обычных файлов, символические ссылки могут указывать также на каталоги.


### Пример удаления ссылок

Удалим жесткую ссылку

![alt text](pictures/image-50.png)

Заметим, что после удаления и вывода команды ls счетчик ссылок уменьшился. А теперь удалим сам файл и посмотрим на символическую ссылку. 

![alt text](pictures/image-51.png)

Поскольку теперь символическая ссылка указывает на несуществующий файл, она стала битой. В большинстве дистрибутивов Linux команда ls особым образом настраивается на отображение битых ссылок. Битые ссылки не представляют никакой опасности, но вносят определенную путаницу. При попытке использовать битую ссылку вы увидите:

![alt text](pictures/image-52.png)


Главное, что следует помнить о символических ссылках: большинство операций с файлами воздействуют на целевой элемент, а не на саму ссылку. Однако команда rm является исключением из этого правила. Когда вы удаляете ссылку, удаляется сама ссылка, а не элемент, на который она указывает.

## Глава 5. Работа с командами

### Команда может быть:

* <b>Выполняемой программой</b>, как те файлы, что мы видели в каталоге /usr/bin. (скомпилированные бинари, код на различных ЯП) <br>
* <b>Встроенной командой внутри командной оболочки </b> - например, команды cd, pwd. Это те, которые не требуют дополнительной установки <br>
* <b>Функцией командной оболочки </b> - как пример, пользовательские шелл скрипты, встроенные в окркжение ОС
* <b>Алиасы </b> - команда, которую мы можем определить сами, сконструировав из других команд.
* <b>Ключевые слова </b> - команда, которая по сути является не командой, а частью баш скрипта, например, слово for или if

### Идентификация команд

Часто бывает полезным точно знать, к какому из типов принадлежит команда. Линукс предлагает несколько способов, как это лучше сделать:

* Команда type - строенная утилита, предназначенная для определения типа введённой команды и способа её интерпретации оболочкой. Если команда - внешний исполняемый файл, выводит путь к нему в системе.
Помогает узнать, как именно будет выполнена команда, если её ввести в терминале

 Например,

![alt text](pictures/image-53.png)

#### Для чего это нужно

1. Проверить, не подменён ли псевдонимом или функцией стандартный вызов команды (например, чтобы избежать неожиданных или вредоносных действий, пример *alias rm='rm -i'*)
2. Определить, где именно находится исполняемый файл команды
3. Убедиться, что команда действительно существует и будет выполнена ожидаемым образом

* Команда which - определение местоположения выполняемого файла


* Показывает, где именно находится исполняемый файл команды
* Помогает проверить, установлена ли команда и доступна ли она в текущем окружении
* Используется для отладки, чтобы убедиться, что запускается именно нужная версия программы.
* При наличии алиасов может показать их определение вместе с путём к исполняемому файлу
* Опция -a позволяет вывести все найденные в PATH экземпляры команды, а не только первый

Например:

![alt text](pictures/image-54.png)


which ищет только исполняемые программы, она не способна выявлять встроенные команды или псевдонимы, замещающие фактические исполняемые программы. Если попытаться с помощью which определить местоположение встроенной команды (например, cd), мы либо ничего не получим, либо получим сообщение
об ошибке.

![alt text](pictures/image-55.png)

### Получение документации с описанием команд

## help — получение справки для встроенных команд
bash имеет встроенную справку для каждой встроенной команды. Чтобы получить ее, введите help с именем встроенной команды. Например:

![alt text](pictures/image-56.png)

Квадратные скобки в описании синтаксиса команды указывают на необязательность элемента. Вертикальная черта используется для перечисления взаимоисключающих вариантов. В примере с описанием команды
cd, приведенном выше, ее синтаксис описывается как

cd [-L|[-P[-e]]] [dir]

Эта форма записи говорит, что команда cd может принимать необязательный параметр -L или -P и необязательный аргумент dir. Если указан параметр -P, вместе с ним можно также передать параметр -e.

--help — вывод инструкции по использованию
Многие выполняемые программы поддерживают параметр --help для вывода описания синтаксиса и параметров, поддерживаемых командой. Например:

![alt text](pictures/image-57.png)

Некоторые программы не поддерживают параметр --help, но вы все равно про-
буйте передать его. Часто в результате выводится сообщение об ошибке, содержа-
щее ту же информацию о порядке использования.


## man — вывод страниц справочного руководства
Большинство программ, предназначенных для использования в командной строке, предоставляют официальную документацию, которую называют страницей справочного руководства (man-страницу). Для просмотра этих страниц используется специальная программа постраничного просмотра man. Важно, что страницы справочного руководства обычно не включают примеры использования, и их главная цель — служить справочником, а не инструкцией по использованию. Например,

![alt text](pictures/image-58.png)

man - это большое справочное руководство, которое разбито на разделы и охватывает не только  пользовательские команды, но и команды системного администрирования, форматы файлов и т.д. Ниже представлены разделы:

![alt text](pictures/image-59.png)


Иногда, чтобы найти искомое, нужно заглянуть в конкретный раздел. Это актуально для форматов файлов, названия которых часто совпадают с именами команд. Если номер раздела не указан, man всегда будет возвращать первую найденную страницу, обычно из раздела 1. Ниже приведен пример прямого указания номера
раздела:

*man 5 passwd*

выводит страницу с описанием формата файла /etc/passwd


![alt text](pictures/image-60.png)

## apropos — вывод списка подходящих команд

Кроме того, существует возможность найти страницы справочного руководства для близких совпадений с искомым термином. Несмотря на неточность, этот подход иногда оказывается полезным. Это очень удобно, когда вы знаете, что хотите сделать, но не помните точное название команды.
Ниже приводится пример поиска страниц справочного руководства по слову partition:

![alt text](pictures/image-61.png)

## whatis — вывод очень краткого описания команды
Программа whatis выводит имя и однострочное описание из страницы справочного руководства, соответствующей искомому слову:

![alt text](pictures/image-62.png)

## info — вывод записи из справочного руководства Info
В проекте GNU имеется альтернативное руководство Info, которое часто называют info-страницами. Info-страницы выводятся с помощью программы чтения с подходящим названием info. Info-страницы содержат гиперссылки, подобно веб-страницам. Например:


![alt text](pictures/image-63.png)


## Просмотр файлов в архиве

Пакет gzip включает специальную версию less с именем zless, которая выводит содержимое текстовых файлов, сжатых архиватором gzip (ещё zcat для просмотра коротких файлов). Например, у нас есть большой текстовый файл, который находится в архиве gzip. Его можно просмотреть, не распаковывая архив с помощью команды zless. Например:

![alt text](pictures/image-64.png)

### Создание собственных команд с помощью alias

Для начала посмотрим, как можно уместить в одной строке несколько команд - для этого нужно просто отделить их друг от друга точкой с запятой:


![alt text](pictures/image-65.png)

Как видите, мы поместили три команды в одну строку. Первая выполняет переход в каталог /usr, вторая выводит его содержимое, и третья осуществляет возврат в предыдущий каталог (команда cd -), поэтому по завершении мы оказываемся там же, где и были. Давайте теперь с помощью alias превратим эту последова-
тельность в новую команду. Первое, что мы должны сделать, — придумать имя для новой команды. Пусть это будет test. Но прежде чем продолжить, хорошо бы проверить, не занято ли уже имя test. Для этого воспользуемся командой type:

![alt text](pictures/image-66.png)


Как мы видим, это имя уже занято. Определим незанятое имя и создадим алиас:

![alt text](pictures/image-67.png)


За командой alias следует имя, сразу за которым (то есть без пробелов) следует знак «равно» и строка в кавычках, описывающая действие, присваиваемое имени. После определения псевдонима его можно использовать везде, где ожидается коман­да.

![alt text](pictures/image-68.png)


Существует одна маленькая проблема, связанная с определением псевдонимов в командной строке. Они исчезают по завершении сеанса работы с командной оболочкой. Как исправить ситуацию мы рассмотрим позже.