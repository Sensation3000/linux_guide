## Содержание

### Часть III Типичные задачи и основные инструменты
- [Глава 14. Управление пакетами](#глава-14-управление-пакетами)
- [Глава 15. Устройства хранения](#глава-15-устройства-хранения)

## Глава 14. Управление пакетами

Общаясь с другими членами сообщества Linux, мы услышим массу мнений о том,
какой дистрибутив Linux лучше. Часто обзоры дистрибутивов выглядят довольно
глупыми, скатываясь к сравнению, например, привлекательности обоев рабочего
стола (некоторые отвергают Ubuntu, потому что им не нравится цветовая схема по
умолчанию!) и других тривиальных особенностей.
Самой важной отличительной чертой дистрибутива является система управления
пакетами и активность сообщества, поддерживающего дистрибутив. Поработав
с Linux достаточно долгое время, легко заметить, насколько динамичен программный ландшафт этой системы. Он находится в постоянном движении. Большинство создателей основных дистрибутивов Linux выпускают новые версии каждые шесть месяцев, а множество отдельных программ обновляется каждый день. Чтобы не отставать от этой лавины программного обеспечения, нам нужен хороший
инструмент для управления пакетами.

Управление пакетами (package management) — это методика установки и управления программным обеспечением в системе.

Вообще существуют несколько способов установки приложений в линуксе:

* Графический режим (в Ubuntu это app center)
* Менеджеры пакетов (через терминал)
* Установка уже скачанных пакетов с официальных сайтов разработчика
* Универсальные форматы пакетов (snap/flatpak). Позволяет устанавливать новейшие версии пакетов вне зависимости от дистрибутивов
* Установка из исходных кодов (с компиляцией исходного кода)
* Подключение сторонних репозиториев, если нужного приложения нет в стандартных

### Системы пакетов

Разные дистрибутивы используют различные системы пакетов, и, как правило, пакеты, подготовленные для одного дистрибутива, несовместимы с другими. В большинстве дистрибутивов используется одна из двух основных технологий упаковки: разработанная создателями дистрибутива Debian с пакетами .deb и разработанная создателями дистрибутива Red Hat с пакетами .rpm. Существует несколько важных исключений, таких как Gentoo, Slackware и Arch, но в большинстве других дистрибутивов используется одна из двух основных систем, что показано в таблице ниже.

![alt text](pics_third_chapter/image.png) 

### Как действует система пакетов

Способ распространения программ, используемый в индустрии патентованного
программного обеспечения, обычно включает покупку установочного носителя,
такого как «установочный диск», и последующий запуск мастера установки нового приложения в систему (Windows).
Linux действует иначе. Практически все программное обеспечение для системы
Linux находится в Интернете. Большая его часть предоставляется создателями
дистрибутивов в форме файлов пакетов, а остальная часть доступна в исходном
коде, который можно установить вручную. Мы еще поговорим об установке программ путем компиляции исходного кода в последующих главах.

### Файлы пакетов

Основной единицей программного обеспечения в системе пакетов является файл
пакета. Файл пакета — это сжатая коллекция файлов, составляющих программный пакет. Пакет может состоять из множества программ и файлов с данными, поддерживающих программы. Помимо файлов для установки, файл пакета включает также метаданные с информацией о пакете, например текстовым описанием
пакета и его содержимого. Дополнительно многие пакеты включают сценарии для
выполнения настроек до и после установки пакета.

## Репозитории

Некоторые проекты самостоятельно создают пакеты и дистрибутивы своего программного обеспечения, и все же большинство пакетов в наше время собирается
создателями дистрибутивов и заинтересованными третьими сторонами. Готовые
пакеты помещаются в центральный репозиторий дистрибутива, где они становятся доступными для пользователей. Репозиторий может содержать тысячи пакетов, специально собранных для дистрибутива.
Для дистрибутива может поддерживаться несколько разных репозиториев с про-
граммным обеспечением, находящимся на разных этапах разработки. 

* тестовый репозиторий, содержащий недавно созданные пакеты, которые предназначены для смельчаков, пытающихся отыскать ошибки до того, как пакеты попадут в основной дистрибутив. 
* репозиторий для разработки, куда помещаются пакеты, продолжающие разрабатываться и предназначенные для включения в ближайший выпуск дистрибутива.
* сторонние репозитории. Они необходимы для распространения программного обеспечения, которое по юридическим причинам, связанным с патентами или законами об управлении цифровыми правами (Digital Rights Management, DRM), не может быть включено в дистрибутив. Самым известным случаем является поддержка шифрования DVD, которая считается незаконной в Соединенных Штатах. Сторонние репозитории располагаются в странах, где патенты или законы, ограничивающие распространение программного обеспечения, отсутствуют или действуют иначе. Эти репозитории обычно полностью независимы от поддерживаемого ими дистрибутива, и для их использования нужно знать об их существовании и вручную включать их в конфигурационные файлы с настройками системы управления пакетами.

## Зависимости

Программы редко действуют в одиночку; чаще они полагаются на наличие других
программных компонентов. Стандартные операции, такие как ввод/вывод, выполняются процедурами, которые совместно используются многими
программами. Эти процедуры хранятся в так называемых разделяемых библиотеках, предоставляющих важные услуги нескольким программам.
Если пакету требуется некий общий ресурс, такой как разделяемая библиотека,
про него говорят, что он имеет зависимость. Современные системы управления
пакетами поддерживают некоторые методы разрешения зависимостей, — это гарантирует, что после установки пакета в системе будут также установлены все его зависимости.


## Высоко- и низкоуровневые инструменты управления пакетами

Системы управления пакетами обычно включают инструменты двух типов:

* низкоуровневые инструменты, решающие такие задачи, как установка и удале-
ние файлов пакетов;
* высокоуровневые инструменты, выполняющие поиск в метаданных и разрешение зависимостей.

В этой главе мы посмотрим, какие инструменты входят в состав систем на основе Debian, а также в состав последних продуктов Red Hat. Несмотря на то что все дистрибутивы на основе Red Hat опираются на одну и ту же низкоуровневую программу (rpm), они используют разные высокоуровневые инструменты. В таблице ниже приведены инструмены управления пакетами. 

![alt text](pics_third_chapter/image-1.png) 

## Типичные задачи управления пакетами

С помощью инструментов командной строки для управления пакетами можно
выполнить множество разных операций. Мы рассмотрим наиболее типичные из
них. Вы должны знать, что низкоуровневые инструменты поддерживают также
создание файлов пакетов, но эта тема выходит за рамки данной книги.
В следующем обсуждении под термином имя_пакета будет подразумеваться фактическое имя пакета, а под термином файл_пакета — имя файла пакета.

## Поиск пакета в репозитории

Используя высокоуровневые инструменты для поиска метаданных в репозитории, можно найти пакет по его имени или описанию.


![alt text](pics_third_chapter/image-2.png) 

Вот пример поиска текстового редактора emacs в системе Red Hat с помощью
коман­ды yum:

yum search emacs

## Установка пакета из репозитория

Высокоуровневые инструменты позволяют загрузить пакет из репозитория
и установить его с полным разрешением всех зависимостей.


![alt text](pics_third_chapter/image-3.png) 

Вот пример установки текстового редактора emacs в системе Debian из репозито-
рия apt:

apt-get update; apt-get install emacs

## Установка пакета из файла пакета

Если файл пакета загружен из источника, не являющегося репозиторием, его
можно установить непосредственно (без разрешения зависимостей) с использо-
ванием низкоуровневого инструмента.


![alt text](pics_third_chapter/image-4.png)

Пример: если с некоторого сайта, не являющегося репозиторием, был загружен
файл emacs-22.1-7.fc7-i386.rpm, его можно установить в систему Red Hat командой

rpm -i emacs-22.1-7.fc7-i386.rpm

## ПРИМЕЧАНИЕ

Поскольку этот прием установки основан на использовании низкоуровневой
программы rpm, он не выполняет разрешения зависимостей. Если программа rpm
обнаружит неразрешенную зависимость, она завершится с сообщением об ошибке.

## Удаление пакета

Пакеты можно удалять с помощью и низкоуровневых, и высокоуровневых инструментов.

![alt text](pics_third_chapter/image-5.png)

Пример: удалить пакет emacs из системы Debian можно командой:
apt-get remove emacs

Этот способ можно использовать, если предполагается, что в будущем пакет будет использоваться.

Ещё немаловажной командой являетя purge

apt-get purge emacs

Эта команда удаляет пакет и всю его конфигурацию, пользовательские файлы остаются, но конфиги в /etc будут удалены. 

Но если надо очистить систему полностью от неиспользуемых зависимостей (если удалённому пакету нужны сторонние зависимости, то ни remove, ни purge не удалит их), то надо использовать другую команду:

apt-get autoremove

Некоторые полезные команды:

apt-get clean

Используется для очистки локального кеша менеджера пакетов APT, удаляет все загруженные .deb пакеты в каталоге /var/cache/apt/archives/ и его подкаталогах, освобождая место на дисках. То есть, при скачивании пакетов с помощью APT,  этот кеш сохраняются пакеты, чтобы можно было в дальнейшем их использовать. 

apt-get autoclean 

Удаляет только устаревшие пакеты, которые больше нельзя загрузить из репозитория, а apt-get clean - абсолютно все пакеты из кеша. 

## Обновление пакетов из репозитория

Наиболее типичной задачей управления пакетами является поддержание системы
в актуальном состоянии обновлением пакетов до последних версий. Высокоуровневые инструменты способны выполнять эту важную задачу за один шаг.

![alt text](pics_third_chapter/image-6.png)

Пример: следующая команда применит все обновления, доступные для пакетов,
установленных в системе на основе Debian:

apt-get update; apt-get upgrade

Можно ещё ставить ключ -y, который говорит, чтобы на все вопросы команда отвечала yes по дефолту. 


Ещё есть команда apt-get dist-upgrade, которая является как бы расширенной версией apt-get upgrade. Она может удалять существующие пакеты и устанавливать новые, чтобы корректно разрешать зависимости между пакетами. Позволяет обновить пакеты за счёт удаления менее значимых. 

## Обновление пакета из файла пакета

Если обновленная версия пакета была загружена из источника, не являющегося
репозиторием, ее можно установить, заменив предыдущую версию.


![alt text](pics_third_chapter/image-7.png)

Пример: обновить установленную программу emacs до версии, содержащей в файле пакета emacs-22.1-7.fc7-i386.rpm, в системе Red Hat можно командой

rpm -U emacs-22.1-7.fc7-i386.rpm

## ПРИМЕЧАНИЕ

dpkg не имеет параметра, отвечающего за обновление пакета вместо установки,
как в программе rpm.

## Список установленных пакетов

Команды в таблице ниже можно использовать для вывода списка всех пакетов, установленных в системе.


![alt text](pics_third_chapter/image-8.png)

## Определение, установлен ли пакет

С помощью низкоуровневых инструментов из таблицы ниже можно определить, был
ли установлен определенный пакет.

![alt text](pics_third_chapter/image-9.png)

Пример: определить, был ли установлен пакет emacs в системе Debian, можно
­командой

dpkg -s emacs

## Вывод информации об установленном пакете

Если известно имя установленного пакета, с помощью команд из таблицы ниже можно получить описание пакета.

![alt text](pics_third_chapter/image-10.png)

Пример: получить описание пакета emacs в системе Debian можно командой

apt-cache show emacs

## Поиск пакета по установленному файлу

Определить, в составе какого пакета был установлен некий файл, можно с помо-
щью команд из таблице ниже.

![alt text](pics_third_chapter/image-11.png)

Пример: узнать, в составе какого пакета был установлен файл /usr/bin/vim в си-
стеме Red Hat, можно командой

rpm -qf /usr/bin/vim

## Заключение

В последующих главах мы исследуем множество программ, решающих широкий
спектр прикладных задач. Хотя большинство этих программ обычно устанавливается по умолчанию, иногда возникает необходимость установить дополнительные
пакеты. С вновь обретенными знаниями (и пониманием) особенностей управления пакетами вы без труда сможете установить дополнительные программы
и управлять ими.

## МИФ ОБ УСТАНОВКЕ ПРОГРАММНОГО ОБЕСПЕЧЕНИЯ В LINUX

Те, кто прежде использовал другие платформы, иногда становятся жертвами
мифов о сложности установки программного обеспечения в Linux и верят, что
многообразие систем управления пакетами, используемых разными дистрибутивами, является серьезной помехой. Вообще-то и правда — помехой, только
не для пользователей, а для производителей патентованного программного
обеспечения, желающих распространять свои программы только в виде дво-
ичных файлов.
Драйверы устройств распространяются почти так же, только они не выделяются
в отдельные пакеты в репозитории дистрибутива, а включаются в ядро Linux. Можно сказать, что в Linux нет такого понятия, как «диск с драйверами». Либо ядро поддерживает данное устройство, либо нет, а ядро Linux поддерживает огромное число устройств. В действительности намного больше, чем Windows. Конечно, едва ли вас утешит информация, что нужное вам устройство не поддерживается ядром. Однако если такое случится, ищите причину. Отсутствие драйвера поддержки обычно обусловлено одной из следующих причин:

* Устройство слишком новое. Так как многие производители аппаратного обе-
спечения не очень активно поддерживают Linux, задача написать драйвер для
включения в ядро ложится на членов сообщества Linux. А это требует времени.
* Устройство чересчур экзотическое. Не все дистрибутивы включают все
возможные драйверы устройств. Для каждого дистрибутива настраивается
свое ядро, и так как ядра настраиваются до мелочей (благодаря чему от-
крывается возможность использовать Linux в самых разных устройствах, от
наручных часов до больших ЭВМ), создатели дистрибутива могли пропустить
ваше устройство. Найдя и загрузив исходный код драйвера, вы (да, да — вы)
сможете скомпилировать и установить драйвер самостоятельно. Это не очень
сложно, скорее утомительно. О компиляции программного обеспечения мы
поговорим в последующих главах.
* Производители аппаратного обеспечения что-то скрывают. Производитель не выпустил либо исходный код драйвера для Linux, либо документацию, на основе которой можно было бы написать драйвер. Это означает, что
производитель аппаратного обеспечения пытается сохранить программные
интерфейсы устройства в секрете. Так как мы предпочитаем не использовать
засекреченные устройства в своих компьютерах, я предлагаю удалить это нетолерантное устройство и отправить его в кучу из других бесполезных гаджетов.

## Глава 15. Устройства хранения

Linux обладает удивительными возможностями работы с устройствами хранения, такими как жесткие диски, сетевые хранилища или виртуальные устройства хранения, например RAID массивы и LVM (Logical Volume Manager — диспетчер логических томов).

### Что такое диспетчер логических томов LVM?

LVM аккумулирует пространство, взятое из разделов или целых дисков, чтобы сформировать логический контейнер (Группа томов). Группа томов далее делится на логические разделы, называемые логическими томами. Проще говоря, LVM группирует все ваше пространство хранения в пул и позволяет вам создавать тома (логические тома) из этого пула. Преимущество использования LVM перед стандартным разделом заключается в том, что LVM предлагает вам больше гибкости и возможностей. Он позволяет онлайн изменять размеры логических групп и логических томов. Поэтому, если в каком-либо из ваших логических разделов закончилось место, вы можете легко увеличить размер раздела, используя свободное место в пуле.Вы также можете экспортировать и импортировать разделы. LVM также поддерживает зеркалирование и создание моментальных снимков логических томов.

Для выполнения упражнений к этой главе нам понадобится флеш-диск (флешка),
подключаемый к порту USB компьютера и диск CD-RW (для систем, оборудованных пишущим приводом CD-ROM).

Мы познакомимся со следующими командами:
* mount — монтирует файловые системы;
* umount — размонтирует файловые системы;
* fsck — проверяет и восстанавливает файловые системы;
* fdisk — инструмент для работы с таблицей разделов;
* mkfs — создает файловые системы;
* dd — выполняет запись данных блоками непосредственно в устройство;
* genisoimage (mkisofs) — создает файл образа ISO 9660;
* wodim (cdrecord) — записывает данные на оптический носитель;
* md5sum — вычисляет контрольную сумму MD5.

### Монтирование и размонтирование устройств хранения

Первый шаг в управлении устройствами хранения — подключение самого
устройства к дереву файловой системы. Этот процесс называется монтированием и позволяет устройству участвовать в работе операционной системы. Linux
поддерживает единое дерево файловой системы, к разным точкам которого подключаются дополнительные устройства. Этот подход отличается от используемо-
го в других операционных системах, таких как Windows, где каждому устройству
соответствует отдельное дерево файлов и каталогов (например, C:\, D:\ и т. д.).

В файле с именем /etc/fstab (сокращенно от «file system table» — таблица файло-
вых систем) перечисляются устройства (обычно разделы жесткого диска), мон-
тируемые на этапе загрузки. Ниже приводится пример содержимого /etc/fstab из
системы Fedora:


![alt text](pics_third_chapter/image-12.png)

Большинство файловых систем из перечисленных в приведенном примере являются виртуальными, и наше обсуждение к ним неприменимо. Наибольший интерес для нас в рамках исследования данной темы представляют первые три:


![alt text](pics_third_chapter/image-13.png)

Это разделы жесткого диска. Каждая строка включает шесть полей, описание ко-
торых приводится в таблице ниже.

![alt text](pics_third_chapter/image-14.png)

### Просмотр списка смонтированных файловых систем

Для монтирования файловых систем используется команда mount. Если ввести
команду без аргументов, она выведет список файловых систем, смонтированных
в настоящий момент в Ubuntu:

![alt text](pics_third_chapter/image-15.png)

Приведем подобный список для Fedora

[me@linuxbox ~]$ mount <br>
/dev/sda2 on / type ext4 (rw) <br>
proc on /proc type proc (rw) <br>
sysfs on /sys type sysfs (rw) <br>
devpts on /dev/pts type devpts (rw,gid=5,mode=620) <br>
/dev/sda5 on /home type ext4 (rw) <br>
/dev/sda1 on /boot type ext4 (rw) <br>
tmpfs on /dev/shm type tmpfs (rw) <br>
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw) <br>
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw) <br>
fusectl on /sys/fs/fuse/connections type fusectl (rw) <br>
/dev/sdd1 on /media/disk type vfat (rw,nosuid,nodev,noatime, uhelper=hal uid=500,ut <br>

Список имеет следующий формат: устройство on точка_монтирования type тип_
файловой_системы (параметры). Например, первая строка соответствует устройству /dev/sda2, смонтированному как корневая файловая система типа ext4, доступная для чтения и записи (параметр rw). В конце списка можно заметить две
интересные записи. Предпоследняя запись соответствует 2-гигабайтной SD-карте
памяти в устройстве для чтения карт памяти, смонтированной в каталог /media/
disk, последняя запись соответствует сетевому приводу, смонтированному в каталог /misc/musicbox. Для первого эксперимента возьмем привод CD-ROM. Сначала посмотрим, что имеется в системе, перед тем как вставить компакт-диск:


Для первого эксперимента возьмем привод CD-ROM. Сначала посмотрим, что
имеется в системе, перед тем как вставить компакт-диск:
[me@linuxbox ~]$ mount <br>
/dev/mapper/VolGroup00-LogVol00 on / type ext4 (rw) <br>
proc on /proc type proc (rw) <br>
sysfs on /sys type sysfs (rw) <br>
devpts on /dev/pts type devpts (rw,gid=5,mode=620) <br>
/dev/hda1 on /boot type ext4 (rw) <br>
tmpfs on /dev/shm type tmpfs (rw) <br>
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw) <br>
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw) <br>

Этот список получен в системе CentOS 5, где для создания корневой файловой
системы используется диспетчер LVM. Подобно многим современным дистрибу-
тивам Linux, эта система пытается автоматически монтировать компакт-диски.
Вставив в привод компакт-диск, мы увидим следующее:

[me@linuxbox ~]$ mount <br>
/dev/mapper/VolGroup00-LogVol00 on / type ext4 (rw) <br>
proc on /proc type proc (rw) <br>
sysfs on /sys type sysfs (rw) <br>
devpts on /dev/pts type devpts (rw,gid=5,mode=620) <br>
/dev/hda1 on /boot type ext4 (rw) <br>
tmpfs on /dev/shm type tmpfs (rw) <br>
none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw) <br>
sunrpc on /var/lib/nfs/rpc_pipefs type rpc_pipefs (rw) <br>
/dev/sdc on /media/live-1.0.10-8 type iso9660 (ro,noexec,nosuid,nodev,uid=500) <br>

Это практически тот же список, с одной дополнительной записью. Последняя запись в списке сообщает, что компакт-диск в приводе CD-ROM (устройство /dev/
sdc в этой системе) смонтирован в каталог /media/live-1.0.10-8 и имеет файловую
систему iso9660 (типичную для компакт-дисков). Обратите внимание на имя
устройства. Когда вы будете проводить эксперимент в своей системе, очень вероятно, что имя устройства у вас будет отличаться.


### ВНИМАНИЕ

В примерах, демонстрируемых ниже, особое внимание обращайте на фактические имена устройств в вашей системе и не используйте имена, приводящиеся
в примерах здесь! Также отметьте, что аудиодиск — это не то же самое, что CD-ROM. Аудиодиск не имеет файловой системы и потому не может быть смонтирован в общепринятом смысле.


Теперь, когда мы знаем имя устройства для привода CD-ROM, размонтируем диск
и повторно смонтируем его в другой каталог в дереве файловой системы. Для это-
го необходимо получить права суперпользователя (способом, соответствующим
вашей системе) и размонтировать диск командой umount:

[me@linuxbox ~]$ su - <br>
Password: <br>
[root@linuxbox ~]# umount /dev/sdc <br>

Следующий шаг: создать новую точку монтирования диска. Точка монтирова-
ния — это самый обычный каталог где-то в дереве файловой системы. В таком каталоге нет ничего необычного. Он даже не должен быть пустым каталогом, правда,монтирование устройства в непустой каталог сделает его прежнее содержимое недоступным, пока устройство не будет размонтировано. Итак, создадим новый каталог:

[root@linuxbox ~]# mkdir /mnt/cdrom <br>

И наконец, смонтируем CD-ROM в новую точку монтирования. Параметр -t позволяет указать тип файловой системы: <br>

[root@linuxbox ~]# mount -t iso9660 /dev/sdc /mnt/cdrom

### ПОЧЕМУ ВАЖНО РАЗМОНТИРОВАТЬ УСТРОЙСТВА

Если взглянуть на вывод команды free, показывающей статистику использования
памяти, можно увидеть статистику с названием buffers (буферы). Компьютерные
системы проектируются так, чтобы работать максимально быстро. Но медленные
устройства препятствуют этому. Ярким примером служат принтеры. Даже самый
быстрый принтер выглядит чрезвычайно медлительным по компьютерным стандартам. В давние времена при попытке распечатать екстовый документ компьютер мог стать недоступным до конца печати. Компьютер не мог посылать данные принтеру быстрее, чем тот мог их обработать, а принтеры не могли работать быстрее, потому что не могли быстро печатать. Эта проблема была решена созданием буфера печати, устройства, содержащего некоторый объем ОЗУ и находящегося между компьютером и принтером. При наличии буфера печати компьютер мог послать данные в буфер печати, который сохранял их в быстрой памяти ОЗУ, и компьютер возвращался к работе, не дожидаясь конца печати. В то же время буфер печати мог передавать данные принтеру из своей памяти со скоростью, приемлемой для принтера.
Идея буферизации широко используется для увеличения производительности
компьютеров — необходимость работы с медленными устройствами не должна
ухудшать производительность системы. Операционные системы хранят данные, прочитанные с устройства и предназначенные для записи в устройство,
так долго, насколько это возможно, и используют их, прежде чем фактически
обратиться к медленному устройству. В системе Linux, например, можно заметить, что при продолжительной работе она заполняет всю память. Это не
означает, что Linux «использует» всю память, это означает лишь то, что Linux
использует в своих интересах всю доступную память и буферизует как можно
больше данных.
Буферизация позволяет очень быстро выполнять запись в устройства хранения,
потому что запись в физическое устройство откладывается «на потом». Данные,
предназначенные для устройства, накапливаются в памяти. Время от времени
операционная система записывает эти данные в физическое устройство.
Размонтирование устройства влечет за собой запись всех оставшихся данных в это
устройство, чтобы его можно было безопасно извлечь. Если носитель извлечь, не
выполнив размонтирования, есть вероятность, что не все данные, предназначенные для устройства, будут записаны в него. Иногда эти данные могут включать
жизненно важные обновления каталогов, отсутствие которых может привести
к повреждению файловой системы — одной из самых больших неприятностей,
которые могут случиться с компьютером.


После этого можно исследовать содержимое компакт-диска в новой точке монти-
рования:

[root@linuxbox ~]# cd /mnt/cdrom <br>
[root@linuxbox cdrom]# ls <br>

Обратите внимание, что происходит при попытке размонтировать компакт-диск:

[root@linuxbox cdrom]# umount /dev/sdc <br>
umount: /mnt/cdrom: device is busy <br>

В чем причина? Устройство нельзя размонтировать, если оно используется каким-
то пользователем или другим процессом. В данном случае мы изменили текущий
рабочий каталог, перенеся его в точку монтирования компакт-диска, что и стало
причиной занятости устройства. Эту проблему легко исправить, перенеся текущий
рабочий каталог куда-нибудь в другое место за пределами точки монтирования:

[root@linuxbox cdrom]# cd <br>
[root@linuxbox ~]# umount /dev/hdc <br>
Теперь устройство было успешно размонтировано. <br>

### Определение названий устройств

Иногда сложно определить имя устройства. В прошлом это было проще. Устройство всегда находилось в одном месте и никогда не менялось. Unix-подобные системы именно так и действовали. Во времена, когда разрабатывалась система Unix, для «смены дискового устройства» требовалось использовать подъемник, чтобы извлечь из комнаты с ЭВМ устройство размером со стиральную машину.
Конечно, можно монтировать устройства, чтобы узнавать их названия постфактум. Но как быть тем, кто управляет сервером или каким-то другим окружением, где автоматическое монтирование не поддерживается? Как в этом случае определить название устройства?
Сначала давайте посмотрим, как система выбирает названия для устройств. Если
вывести содержимое каталога /dev (где живут все устройства), можно увидеть
значительное число устройств:

[me@linuxbox ~]$ ls /dev <br>

Содержимое списка показывает некоторые шаблоны в именовании устройств, неполный список которых приводится в таблице ниже.


![alt text](pics_third_chapter/image-16.png)

Кроме того, во многих системах можно увидеть такие символические ссылки, как
/dev/cdrom, /dev/dvd и /dev/floppy, которые ссылаются на фактические файлы
устройств и предусмотрены для удобства.

Если вам доведется работать в системе, которая не монтирует автоматически
съемные носители, вы можете использовать следующий прием для определения
названий таких устройств после их подключения. Сначала запустите мониторинг
содержимого файла /var/log/messages или /var/log/syslog в режиме реального времени (для этого могут потребоваться права суперпользователя):

[me@linuxbox ~]$ sudo tail -f /var/log/messages <br>

Эта команда выведет несколько последних строк из файла и приостановится.
Далее подключите извлекаемое устройство.

Когда вывод опять приостановится, нажмите CTRL+C, чтобы вернуться в пригла-
шение командной строки. Наибольший интерес для нас представляют строки
с упоминанием имени устройства [sdb], соответствующего нашим ожиданиям
в отношении названия устройства диска SCSI. Cледующие две строки являются
для нас особенно показательными:

Jul 23 10:07:59 linuxbox kernel: sdb: sdb1 <br>
Jul 23 10:07:59 linuxbox kernel: sd 3:0:0:0: [sdb] Attached SCSI removable disk <br>


Они сообщают, что имя /dev/sdb соответствует всему устройству, а имя /dev/
sdb1 — первому разделу на этом устройстве. 

### СОВЕТ

Прием с использованием команды tail -f /var/log/messages демонстрирует отличный способ наблюдения за происходящим в системе в режиме реального
времени.


Зная имя устройства, можно смонтировать флеш-диск:

[me@linuxbox ~]$ sudo mkdir /mnt/flash <br>
[me@linuxbox ~]$ sudo mount /dev/sdb1 /mnt/flash <br>

В конце можно выполнить команду df -h (disk free), чтобы посмотреть свободное дисковое пространство.

Имя устройства сохраняется неизменным, пока оно остается физически подключенным к компьютеру и до перезагрузки компьютера.

### Создание новых файловых систем

Представьте, что вам нужно отформатировать флеш-диск и вместо файловой системы FAT32 создать на нем файловую систему, родную для Linux. Для этого следует выполнить две операции:

1. Создать (при необходимости) новое распределение разделов, если имеющееся
вас не устраивает. <br>
2. Создать новую, пустую файловую систему. <br>

### ВНИМАНИЕ

Следующее упражнение производит форматирование флеш-диска. Используйте
диск, не содержащий ничего, что вам было бы нужно, потому что вся информация на диске будет стерта! И снова: убедитесь, что используете имя устройства,
верное для вашей системы, а не то, которое показано в примере. Игнорирование
этого предупреждения может привести к форматированию (то есть к стиранию)
другого диска!

### Управление разделами с помощью fdisk

Программа fdisk позволяет напрямую выполнять низкоуровневые операции
с дисковыми устройствами (такими, как жесткие диски и флеш-диски). С помощью этого инструмента можно изменять, удалять и создавать разделы на
устройстве. Чтобы приступить к работе с флеш-диском, его нужно сначала размонтировать (если прежде он был смонтирован) и затем запустить программу
fdisk, как показано ниже:

[me@linuxbox ~]$ sudo umount /dev/sdb1 <br>
[me@linuxbox ~]$ sudo fdisk /dev/sdb <br>


Обратите внимание, что здесь нужно указать имя, соответствующее устройству
целиком, то есть всему устройству, без номера раздела. После запуска программы
вы увидите следующее приглашение:

![alt text](pics_third_chapter/image-17.png)

Первое, что следует сделать, — исследовать список имеющихся разделов. Для этого введите команду p, она выведет таблицу разделов на устройстве:

![alt text](pics_third_chapter/image-18.png)

Обратите внимание, что устройство имеет объем 16 Мбайт и единственный раз-
дел (1), занимающий 1008 цилиндров на устройстве. Раздел идентифицирован как раздел Windows 95 FAT32. Некоторые программы используют этот идентификатор, ограничивая виды операций с диском, но чаще изменение идентификатора не влечет серьезных последствий. Однако ради демонстрации мы изменим его, чтобы показать, что это раздел Linux. Для этого нужно сначала узнать, какой идентификатор обозначает разделы Linux. В листинге, приведенном выше, мы видели, что существующий раздел имеет идентификатор b (столбец Id). Чтобы увидеть список известных типов разделов, вернитесь к меню программы и обратите внимание на пункт:

l список известных типов разделов

Если ввести команду l, появится длинный список допустимых типов разделов.
Среди них можно увидеть идентификатор b типа существующего раздела и иден-
тификатор 83 для Linux. Вернемся обратно к меню программы, где можно увидеть
команду изменения идентификатора раздела:

t изменить тип раздела

Введите t и затем новый идентификатор:
Command (m for help): t <br>
Selected partition 1 <br>
Hex code (type L to list codes): 83 <br>
Changed system type of partition 1 to 83 (Linux) <br>

Это все изменения, которые нам нужно было сделать. До этого момента никаких
изменений на самом устройстве не было произведено (все изменения пока просто
зафиксированы в памяти программы, а не на физическом устройстве), поэтому
теперь запишем измененную таблицу разделов на устройство и выйдем. Для этого
введите команду w:

Command (m for help): w <br>
The partition table has been altered! <br>
Calling ioctl() to re-read partition table. <br>

WARNING: If you have created or modified any DOS 6.x partitions, please see the fdisk manual page for additional information.
Syncing disks. <br>
[me@linuxbox ~]$ <br>

Если бы мы решили оставить устройство в неизменном состоянии, то могли бы
ввести команду q и покинуть программу без записи изменений на устройство.

### Создание новой файловой системы с помощью mkfs

Завершив редактирование разделов (довольно простое, хотя так бывает не всегда),
мы создадим на флеш-диске новую файловую систему. Для этого воспользуемся
программой mkfs (сокращенно от make filesystem — создать файловую систему), способной создавать разные файловые системы. Чтобы создать на устройстве файловую систему ext4, следует передать команде параметр -t с типом файловой системы ext4, затем указать имя устройства и раздел, который требуется отформатировать:


![alt text](pics_third_chapter/image-19.png)

Когда выбирается тип файловой системы ext4, программа выводит массу ин-
формации. Чтобы восстановить на устройстве оригинальную файловую систему
FAT32, следует указать тип файловой системы vfat: <br>

[me@linuxbox ~]$ sudo mkfs -t vfat /dev/sdb1 <br>

Эту процедуру с редактированием разделов и форматированием можно повторять
с любыми дополнительными устройствами хранения, подключаемыми к системе.
Хотя в данном примере мы работали с маленьким флеш-диском, ту же процедуру можно применить и к внутренним жестким дискам, и к другим извлекаемым
устройствам хранения, таким как жесткие USB-диски.

### Проверка и восстановление файловой системы

Знакомясь с файлом /etc/fstab, мы видели некие странные цифры в конце каждой
строки. Каждый раз, когда система загружается, она проверяет целостность фай-
ловых систем перед их монтированием. Эту проверку выполняет программа fsck
(сокращенно от filesystem check — проверка файловой системы). Последнее число
в каждой записи в файле fstab определяет порядок проверки файловых систем.
В примере, приведенном выше, видно, что корневая файловая система проверяет-
ся первой, вслед за ней проверяются файловые системы home и boot. Устройства
с нулем в последнем поле не проверяются стандартными механизмами.
Программа fsck может не только проверить целостность, но и восстановить поврежденные файловые системы с той или иной степенью успеха в зависимости от
масштаба повреждений. В Unix-подобных системах восстановленные фрагменты
файлов помещаются в каталог lost+found, находящийся в корне каждой файловой
системы.

Проверить наш флеш-диск (который предварительно необходимо размонтировать) можно с помощью следующей команды:

[me@linuxbox ~]$ sudo fsck /dev/sdb1 <br>
fsck 1.40.8 (13-Mar-2016) <br>
e2fsck 1.40.8 (13-Mar-2016) <br>
/dev/sdb1: clean, 11/3904 files, 1661/15608 blocks <br>

В настоящее время файловые системы повреждаются крайне редко, если нет ника-
ких проблем с аппаратной частью, таких как выход из строя привода диска. В большинстве файловых систем обнаруженные на этапе загрузки повреждения вызывают
остановку системы с выводом предложения запустить fsck перед продолжением.

### ЧТО ТАКОЕ FSCK?

В культуре Unix слово «fsck» часто используется взамен распространенного ругательства, в котором три буквы совпадают с буквами в имени команды. Это показательно — вы почти наверняка будете произносить упомянутое слово, оказавшись в ситуации, вынуждающей запустить fsck.


### Непосредственное перемещение данных между устройствами

Обычно на компьютерах мы работаем с данными, организованными в файлы, однако
точно так же можно работать с данными в «низкоуровневой» форме. Если взглянуть на содержимое диска, можно увидеть, что оно состоит из множества «блоков»
данных, которые операционная система интерпретирует как файлы и каталоги. Если
бы мы умели интерпретировать диски как простые коллекции блоков данных, мы
смогли бы выполнять множество полезных задач, таких как клонирование дисков.
Эту задачу решает программа dd. Она копирует блоки данных из одного места
в другое. По историческим причинам команда имеет уникальный синтаксис:

dd if=входной_файл of=выходной_файл [bs=размер_блока [count=число_блоков]] <br>

### ВНИМАНИЕ

dd — очень мощная команда. Ее название происходит от data definition (определение данных), но иногда его расшифровывают как destroy disk (уничтожить
диск), потому что пользователи часто допускают ошибки в параметрах if и of.
Всегда дважды проверяйте их, прежде чем нажать ENTER!

Представьте, что у вас есть два флеш-диска USB одинакового размера и вам нужно
создать точную копию первого диска на втором. Допустим, что после подключения к компьютеру им назначаются имена устройств /dev/sdb и /dev/sdc соответственно. В этом случае скопировать содержимое первого диска на второй можно следующей командой: 

dd if=/dev/sdb of=/dev/sdc <br>

Как вариант, если к компьютеру подключено только первое устройство, можно
скопировать его содержимое в обычный файл, который впоследствии использовать для восстановления или копирования:

dd if=/dev/sdb of=flash_drive.img <br>

### Создание образа компакт-диска

Запись на компакт-диски (CD-R или CD-RW) выполняется в два этапа.
* Создается файл образа ISO, являющийся точным образом файловой системы
компакт-диска. 
* Файл образа записывается на носитель (то есть на сам компакт-диск).

### Создание образа-копии компакт-диска

Чтобы создать ISO-образ имеющегося компакт-диска, необходимо с помощью
dd прочитать все блоки с данными с этого компакт-диска и скопировать их в локальный файл. Например, допустим, что у нас есть компакт-диск с дистрибутивом Ubuntu, и мы хотим создать файл ISO-образа, который потом можно будет использовать для создания нескольких копий. Вставив компакт-диск в привод
CD-ROM и определив имя устройства (пусть это будет /dev/cdrom), мы сможем
создать файл ISO-образа следующим способом:

dd if=/dev/cdrom of=ubuntu.iso <br>

Этот прием также применим к дискам DVD с данными, но он не будет работать
с аудиодисками, так как для хранения данных на них файловая система не используется. Если вы хотите скопировать аудиодиск, обратитесь к команде cdrdao.

### Создание образа из коллекции файлов

Создать файл ISO-образа, включающий содержимое некоего каталога, можно
с помощью программы genisoimage. Для этого сначала создадим каталог со всеми необходимыми файлами для включения в образ и затем командой genisoimage
создадим файл образа. Например, если предположить, что вы создали каталог
~/cd-rom-files и наполнили его файлами для записи на компакт-диск, следующая
команда создаст файл образа с именем cd-rom.iso:

genisoimage -o cd-rom.iso -R -J ~/cd-rom-files <br>

Параметр -R требует добавить метаданные расширений Rock Ridge, позволяющих
использовать длинные имена файлов и права доступа к файлам в стиле POSIX.
Аналогично, параметр -J включает расширения Joliet, разрешающие использовать
длинные имена файлов в Windows.

#### Интересно

В руководствах по созданию и записи оптических дисков, таких как CD-ROM и DVD,
которых в избытке на просторах Интернета, часто можно встретить упоминание двух программ, mkisofs и cdrecord. Эти программы были некогда частью
популярного пакета cdrtools, созданного Йоргом Шиллингом (Jörg Schilling).
Летом 2006-го мистер Шиллинг изменил лицензию в части, касающейся пакета
cdrtools, из-за чего она, по мнению многих в сообществе пользователей Linux,
стала несовместимой с GNU GPL. Как результат, на основе cdrtools был создан
альтернативный проект, включающий программы wodim и genisoimage взамен
cdrecord и mkisofs соответственно.

## Запись образа компакт-диска

После подготовки файла образа его можно записать на оптический носитель.
Большинство команд, обсуждаемых ниже, применимы и для записи на носители
CD-ROM и DVD.

## Непосредственное монтирование файла ISO-образа

Существует один трюк, позволяющий монтировать ISO-образы, хранящиеся на
жестком диске, и работать с ними, как если бы это были оптические носители.
Параметр -o loop, добавленный в команду mount (вместе с обязательным параметром -t iso9660, определяющим тип файловой системы), позволяет смонтировать файл образа в дерево файловой системы, как если бы это было обычное устройство:

mkdir /mnt/iso_image <br>
mount -t iso9660 -o loop image.iso /mnt/iso_image <br>

В примере, приведенном выше, мы создали точку монтирования с именем /mnt/
iso_image и затем смонтировали в нее файл образа image.iso. После монтирования
образа с ним можно работать как с настоящим диском CD-ROM или DVD. Не забудьте размонтировать образ, когда он станет не нужен.


## Очистка перезаписываемых компакт-дисков

Перезаписываемые компакт-диски CD-RW нужно стирать, или очищать, перед
повторным использованием. Для этого воспользуемся командой wodim, указав ей
имя устройства пишущего привода компакт-дисков и тип очистки. Программа
wodim предлагает несколько типов очистки. Для минимальной (и самой быстрой)
очистки следует указать тип fast:

wodim dev=/dev/cdrw blank=fast <br>

## Запись образа

Записать образ можно с помощью все той же программы wodim, указав ей имя
устройства пишущего привода компакт-дисков и имя файла образа:

wodim dev=/dev/cdrw image.iso <br>


Помимо имени устройства и файла образа программа wodim поддерживает массу
дополнительных параметров. Чаще других используются параметры -v (обеспечивает вывод подробной информации в ходе записи) и -dao (выполняет запись на
диск в режиме disc-at-once — диск целиком). Режим «диск целиком» следует использовать, если вы собираетесь воспроизводить диски в коммерческих целях. По
умолчанию wodim использует режим track-at-once (по одной дорожке), который
хорошо подходит для записи музыкальных треков.

## Дополнительные сведения

Часто бывает полезно проверить целостность ISO-образа, загруженного из Интернета. В большинстве случаев распространители ISO-образов сопровождают их
файлами с контрольными суммами. Контрольная сумма — это результат экзотических математических вычислений в виде числа, представляющего содержимое
целевого файла. Если содержимое файла образа изменится хотя бы в одном бите,
его контрольная сумма будет отличаться от указанной распространителем. Для
вычисления контрольной суммы чаще всего используется программа md5sum, воз-
вращающая уникальное шестнадцатеричное число:

md5sum image.iso <br>
34e354760f9bb7fbf85c96f6a3f94ece image.iso <br>

Загрузив образ, запустите md5sum для него и сравните результат работы md5sum со
значением, указанным распространителем.

Помимо проверки целостности загруженного файла, программу md5sum можно использовать для проверки вновь записанного оптического носителя. Для этого сначала вычислите контрольную сумму для файла образа, а затем — для носителя. Вся хитрость проверки носителя заключается в том, чтобы ограничить вычисления частью оптического носителя, содержащей образ. Для этого определите число 2048-байтных блоков в образе (запись на оптические носители всегда выполняется блоками по 2048 байт) и прочитайте с носителя ровно столько блоков. Для некоторых типов носителей это не обязательно. Например, компакт-диск, записанный в режиме disc-at-once, можно проверить так:

md5sum /dev/cdrom <br>
34e354760f9bb7fbf85c96f6a3f94ece /dev/cdrom <br>

Многие типы носителей, такие как DVD, требуют точного вычисления числа блоков. Следующий пример демонстрирует проверку целостности файла образа dvd-
image.iso и диска в устройстве /dev/dvd привода DVD. 

md5sum dvd-image.iso; dd if=/dev/dvd bs=2048 count=$(( $(stat -c "%s" dvd-image.iso) / 2048 )) | md5sum











